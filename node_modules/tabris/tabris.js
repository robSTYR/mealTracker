/*!
 * Tabris.js 2.4.2
 * 
 * Copyright (c) 2014, 2017 EclipseSource Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of Tabris.js nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
'use strict';

/**
 * Implementation based on https://github.com/then/promise
 *
 * Original work Copyright (c) 2014 Forbes Lindesay
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function asap(fn) {
  setTimeout(fn, 0);
}

// --- core.js ---

function noop() {}

// States:
//
// 0 - pending
// 1 - fulfilled with _value
// 2 - rejected with _value
// 3 - adopted the state of another promise, _value
//
// once the state is no longer pending (0) it is immutable

// to avoid using try/catch inside critical functions, we
// extract them to here.
var LAST_ERROR = null;
var IS_ERROR = {};

function getThen(obj) {
  try {
    return obj.then;
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallOne(fn, a) {
  try {
    return fn(a);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function tryCallTwo(fn, a, b) {
  try {
    fn(a, b);
  } catch (ex) {
    LAST_ERROR = ex;
    return IS_ERROR;
  }
}

function Promise(fn) {
  if (typeof this !== 'object') {
    throw new TypeError('Promises must be constructed via new');
  }
  if (typeof fn !== 'function') {
    throw new TypeError('not a function');
  }
  Object.defineProperties(this, {
    _deferredState: { value: 0, writable: true },
    _state: { value: 0, writable: true },
    _value: { value: null, writable: true },
    _deferreds: { value: null, writable: true }
  });
  if (fn === noop) {
    return;
  }
  doResolve(fn, this);
}
Promise._onHandle = null;
Promise._onReject = null;
Promise._noop = noop;

Promise.prototype.then = function (onFulfilled, onRejected) {
  if (this.constructor !== Promise) {
    return safeThen(this, onFulfilled, onRejected);
  }
  var res = new Promise(noop);
  handle(this, new Handler(onFulfilled, onRejected, res));
  return res;
};

function safeThen(self, onFulfilled, onRejected) {
  return new self.constructor(function (resolve, reject) {
    var res = new Promise(noop);
    res.then(resolve, reject);
    handle(self, new Handler(onFulfilled, onRejected, res));
  });
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (Promise._onHandle) {
    Promise._onHandle(self);
  }
  if (self._state === 0) {
    if (self._deferredState === 0) {
      self._deferredState = 1;
      self._deferreds = deferred;
      return;
    }
    if (self._deferredState === 1) {
      self._deferredState = 2;
      self._deferreds = [self._deferreds, deferred];
      return;
    }
    self._deferreds.push(deferred);
    return;
  }
  handleResolved(self, deferred);
}

function handleResolved(self, deferred) {
  asap(function () {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      if (self._state === 1) {
        resolve(deferred.promise, self._value);
      } else {
        reject(deferred.promise, self._value);
      }
      return;
    }
    var ret = tryCallOne(cb, self._value);
    if (ret === IS_ERROR) {
      reject(deferred.promise, LAST_ERROR);
    } else {
      resolve(deferred.promise, ret);
    }
  });
}

function resolve(self, newValue) {
  // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
  if (newValue === self) {
    return reject(self, new TypeError('A promise cannot be resolved with itself.'));
  }
  if (newValue && (typeof newValue === 'object' || typeof newValue === 'function')) {
    var then = getThen(newValue);
    if (then === IS_ERROR) {
      return reject(self, LAST_ERROR);
    }
    if (then === self.then && newValue instanceof Promise) {
      self._state = 3;
      self._value = newValue;
      finale(self);
      return;
    } else if (typeof then === 'function') {
      doResolve(then.bind(newValue), self);
      return;
    }
  }
  self._state = 1;
  self._value = newValue;
  finale(self);
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  if (Promise._onReject) {
    Promise._onReject(self, newValue);
  }
  finale(self);
}

function finale(self) {
  if (self._deferredState === 1) {
    handle(self, self._deferreds);
    self._deferreds = null;
  }
  if (self._deferredState === 2) {
    for (var i = 0; i < self._deferreds.length; i++) {
      handle(self, self._deferreds[i]);
    }
    self._deferreds = null;
  }
}

function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, promise) {
  var done = false;
  var res = tryCallTwo(fn, function (value) {
    if (done) {
      return;
    }
    done = true;
    resolve(promise, value);
  }, function (reason) {
    if (done) {
      return;
    }
    done = true;
    reject(promise, reason);
  });
  if (!done && res === IS_ERROR) {
    done = true;
    reject(promise, LAST_ERROR);
  }
}

// --- es6-extensions.js ---

//This file contains the ES6 extensions to the core Promises/A+ API

/* Static Functions */

var TRUE = valuePromise(true);
var FALSE = valuePromise(false);
var NULL = valuePromise(null);
var UNDEFINED = valuePromise(undefined);
var ZERO = valuePromise(0);
var EMPTYSTRING = valuePromise('');

function valuePromise(value) {
  var p = new Promise(Promise._noop);
  p._state = 1;
  p._value = value;
  return p;
}
Promise.resolve = function (value) {
  if (value instanceof Promise) {
    return value;
  }

  if (value === null) {
    return NULL;
  }
  if (value === undefined) {
    return UNDEFINED;
  }
  if (value === true) {
    return TRUE;
  }
  if (value === false) {
    return FALSE;
  }
  if (value === 0) {
    return ZERO;
  }
  if (value === '') {
    return EMPTYSTRING;
  }

  if (typeof value === 'object' || typeof value === 'function') {
    try {
      var then = value.then;
      if (typeof then === 'function') {
        return new Promise(then.bind(value));
      }
    } catch (ex) {
      return new Promise(function (resolve, reject) {
        return reject(ex);
      });
    }
  }
  return valuePromise(value);
};

Promise.all = function (arr) {
  var args = Array.prototype.slice.call(arr);
  return new Promise(function (resolve, reject) {
    if (args.length === 0) {
      return resolve([]);
    }
    var remaining = args.length;
    function res(i, val) {
      if (val && (typeof val === 'object' || typeof val === 'function')) {
        if (val instanceof Promise && val.then === Promise.prototype.then) {
          while (val._state === 3) {
            val = val._value;
          }
          if (val._state === 1) {
            return res(i, val._value);
          }
          if (val._state === 2) {
            reject(val._value);
          }
          val.then(function (val) {
            return res(i, val);
          }, reject);
          return;
        } else {
          var then = val.then;
          if (typeof then === 'function') {
            var p = new Promise(then.bind(val));
            p.then(function (val) {
              return res(i, val);
            }, reject);
            return;
          }
        }
      }
      args[i] = val;
      if (--remaining === 0) {
        resolve(args);
      }
    }
    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.reject = function (value) {
  return new Promise(function (resolve, reject) {
    return reject(value);
  });
};

Promise.race = function (values) {
  return new Promise(function (resolve, reject) {
    return values.forEach(function (value) {
      return Promise.resolve(value).then(resolve, reject);
    });
  });
};

/* Prototype Methods */

Promise.prototype.catch = function (onRejected) {
  return this.then(null, onRejected);
};

/* Inspection Methods */

function isPending(promise) {
  return promise._state === 0;
}

function isRejected(promise) {
  return promise._state === 2;
}

function getPromiseResult(promise) {
  return promise._value;
}

global.Promise = Promise;

if (typeof window === 'undefined') {
  global.window = global;
}

if (!Object.assign) {
  Object.defineProperty(Object, 'assign', {
    enumerable: false,
    configurable: true,
    writable: true,
    value: assign
  });
}

/**
 * Original code from
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 */
function assign(target) {
  if (target === undefined || target === null) {
    throw new TypeError('Cannot convert first argument to object');
  }
  var to = Object(target);
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    if (source === undefined || source === null) {
      continue;
    }
    var keys = Object.keys(Object(source));
    for (var key of keys) {
      var desc = Object.getOwnPropertyDescriptor(source, key);
      if (desc !== undefined && desc.enumerable) {
        to[key] = source[key];
      }
    }
  }
  return to;
}

/*
 * Implementation based on Node.js https://github.com/nodejs/node/
 *
 * Original work Copyright Copyright Joyent, Inc. and other Node contributors.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to permit
 * persons to whom the Software is furnished to do so, subject to the
 * following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
 * NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
var numbersOnlyRE = /^\d+$/;

var objectHasOwnProperty = Object.prototype.hasOwnProperty;
var propertyIsEnumerable = Object.prototype.propertyIsEnumerable;
var regExpToString = RegExp.prototype.toString;
var dateToISOString = Date.prototype.toISOString;
var errorToString = Error.prototype.toString;

var CIRCULAR_ERROR_MESSAGE = void 0;

// TODO: Add support for Map, Set, MapIterator, SetIterator, DataView

function tryStringify(arg) {
  try {
    return JSON.stringify(arg);
  } catch (err) {
    // Populate the circular error message lazily
    if (!CIRCULAR_ERROR_MESSAGE) {
      try {
        var a = {};a.a = a;JSON.stringify(a);
      } catch (err) {
        CIRCULAR_ERROR_MESSAGE = err.message;
      }
    }
    if (err.name === 'TypeError' && err.message === CIRCULAR_ERROR_MESSAGE) {
      return '[Circular]';
    }
    throw err;
  }
}

function format(f) {
  if (typeof f !== 'string') {
    var objects = new Array(arguments.length);
    for (var index = 0; index < arguments.length; index++) {
      objects[index] = inspect(arguments[index]);
    }
    return objects.join(' ');
  }
  if (arguments.length === 1) {
    return f;
  }
  var str = '';
  var a = 1;
  var lastPos = 0;
  for (var i = 0; i < f.length;) {
    if (f.charCodeAt(i) === 37 /*'%'*/ && i + 1 < f.length) {
      if (f.charCodeAt(i + 1) !== 37 /*'%'*/ && a >= arguments.length) {
        ++i;
        continue;
      }
      switch (f.charCodeAt(i + 1)) {
        case 100:
          // 'd'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += Number(arguments[a++]);
          break;
        case 105:
          // 'i'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += parseInt(arguments[a++]);
          break;
        case 102:
          // 'f'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += parseFloat(arguments[a++]);
          break;
        case 106:
          // 'j'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += tryStringify(arguments[a++]);
          break;
        case 115:
          // 's'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += String(arguments[a++]);
          break;
        case 37:
          // '%'
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += '%';
          break;
        default:
          // any other character is not a correct placeholder
          if (lastPos < i) {
            str += f.slice(lastPos, i);
          }
          str += '%';
          lastPos = i = i + 1;
          continue;
      }
      lastPos = i = i + 2;
      continue;
    }
    ++i;
  }
  if (lastPos === 0) {
    str = f;
  } else if (lastPos < f.length) {
    str += f.slice(lastPos);
  }
  while (a < arguments.length) {
    var x = arguments[a++];
    if (x === null || typeof x !== 'object' && typeof x !== 'symbol') {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
}

function inspect(obj) {
  // default options
  var ctx = {
    seen: [],
    breakLength: 60,
    maxArrayLength: 20
  };
  return formatValue(ctx, obj, 2);
}

function arrayToHash(array) {
  var hash = Object.create(null);
  for (var i = 0; i < array.length; i++) {
    var val = array[i];
    hash[val] = true;
  }
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);
  var symbolKeys = Object.getOwnPropertySymbols(value);
  var enumSymbolKeys = symbolKeys.filter(function (key) {
    return propertyIsEnumerable.call(value, key);
  });
  keys = keys.concat(enumSymbolKeys);

  // This could be a boxed primitive (new String(), etc.), check valueOf()
  // NOTE: Avoid calling `valueOf` on `Date` instance because it will return
  // a number which, when object has some additional user-stored `keys`,
  // will be printed out.
  var formatted = void 0;
  var raw = value;
  try {
    // the .valueOf() call can fail for a multitude of reasons
    if (!isDate(value)) {
      raw = value.valueOf();
    }
  } catch (e) {
    // ignore...
  }

  if (typeof raw === 'string') {
    // for boxed Strings, we have to remove the 0-n indexed entries,
    // since they just noisy up the output and are redundant
    keys = keys.filter(function (key) {
      if (typeof key === 'symbol') {
        return true;
      }
      return !(key >= 0 && key < raw.length);
    });
  }

  // On iOS, errors have these extra enumerable fields
  if (isError(value) && tabris.device.platform === 'iOS') {
    keys = keys.filter(function (key) {
      return !['line', 'column', 'sourceURL'].includes(key);
    });
  }

  var constructor = getConstructorOf(value);

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (typeof value === 'function') {
      var ctorName = constructor ? constructor.name : 'Function';
      return '[' + ctorName + (value.name ? ': ' + value.name : '') + ']';
    }
    if (isRegExp(value)) {
      return regExpToString.call(value);
    }
    if (isDate(value)) {
      if (Number.isNaN(value.getTime())) {
        return value.toString();
      } else {
        return dateToISOString.call(value);
      }
    }
    if (isError(value)) {
      return formatError(value);
    }
    // now check the `raw` value to handle boxed primitives
    if (typeof raw === 'string') {
      formatted = formatPrimitive(ctx, raw);
      return '[String: ' + formatted + ']';
    }
    if (typeof raw === 'symbol') {
      formatted = formatPrimitive(ctx, raw);
      return '[Symbol: ' + formatted + ']';
    }
    if (typeof raw === 'number') {
      formatted = formatPrimitive(ctx, raw);
      return '[Number: ' + formatted + ']';
    }
    if (typeof raw === 'boolean') {
      formatted = formatPrimitive(ctx, raw);
      return '[Boolean: ' + formatted + ']';
    }
  }

  var base = '';
  var empty = false;
  var formatter = formatObject;
  var braces = void 0;

  // We can't compare constructors for various objects using a comparison like
  // `constructor === Array` because the object could have come from a different
  // context and thus the constructor won't match. Instead we check the
  // constructor names (including those up the prototype chain where needed) to
  // determine object types.
  if (Array.isArray(value)) {
    // Unset the constructor to prevent "Array [...]" for ordinary arrays.
    if (constructor && constructor.name === 'Array') {
      constructor = null;
    }
    braces = ['[', ']'];
    empty = value.length === 0;
    formatter = formatArray;
  } else if (isArrayBuffer(value)) {
    braces = ['{', '}'];
    keys.unshift('byteLength');
    visibleKeys.byteLength = true;
  } else if (isTypedArray(value)) {
    braces = ['[', ']'];
    formatter = formatTypedArray;
  } else if (isPromise(value)) {
    braces = ['{', '}'];
    formatter = formatPromise;
  } else {
    // Unset the constructor to prevent "Object {...}" for ordinary objects.
    if (constructor && constructor.name === 'Object') {
      constructor = null;
    }
    braces = ['{', '}'];
    empty = true; // No other data than keys.
  }

  empty = empty === true && keys.length === 0;

  // Make functions say that they are functions
  if (typeof value === 'function') {
    var _ctorName = constructor ? constructor.name : 'Function';
    base = ' [' + _ctorName + (value.name ? ': ' + value.name : '') + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + regExpToString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + dateToISOString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  // Make boxed primitive Strings look like such
  if (typeof raw === 'string') {
    formatted = formatPrimitive(ctx, raw);
    base = ' [String: ' + formatted + ']';
  }

  // Make boxed primitive Numbers look like such
  if (typeof raw === 'number') {
    formatted = formatPrimitive(ctx, raw);
    base = ' [Number: ' + formatted + ']';
  }

  // Make boxed primitive Booleans look like such
  if (typeof raw === 'boolean') {
    formatted = formatPrimitive(ctx, raw);
    base = ' [Boolean: ' + formatted + ']';
  }

  // Add constructor name if available
  if (base === '' && constructor) {
    braces[0] = constructor.name + ' ' + braces[0];
  }

  if (empty === true) {
    return '' + braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return regExpToString.call(value);
    } else if (Array.isArray(value)) {
      return '[Array]';
    } else {
      return '[Object]';
    }
  }

  ctx.seen.push(value);
  var output = formatter(ctx, value, recurseTimes, visibleKeys, keys);
  ctx.seen.pop();
  return reduceToSingleString(output, base, braces, ctx.breakLength);
}

function formatNumber(ctx, value) {
  // Format -0 as '-0'. Strict equality won't distinguish 0 from -0.
  if (Object.is(value, -0)) {
    return '-0';
  }
  return '' + value;
}

function formatPrimitive(ctx, value) {
  if (value === undefined) {
    return 'undefined';
  }
  // For some reason typeof null is "object", so special case here.
  if (value === null) {
    return 'null';
  }
  var type = typeof value;
  if (type === 'string') {
    var simple = JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"');
    return '\'' + simple + '\'';
  }
  if (type === 'number') {
    return formatNumber(ctx, value);
  }
  if (type === 'boolean') {
    return '' + value;
  }
  // es6 symbol primitive
  if (type === 'symbol') {
    return value.toString();
  }
}

function formatError(value) {
  if (!value.stack) {
    return '[' + errorToString.call(value) + ']';
  }
  if (tabris.device.platform === 'iOS') {
    return value.constructor.name + ': ' + value.message + '\n  ' + value.stack.split('\n').join('\n  ');
  }
  return value.stack;
}

function formatObject(ctx, value, recurseTimes, visibleKeys, keys) {
  return keys.map(function (key) {
    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, false);
  });
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  var visibleLength = 0;
  var index = 0;
  while (index < value.length && visibleLength < ctx.maxArrayLength) {
    var emptyItems = 0;
    while (index < value.length && !hasOwnProperty(value, String(index))) {
      emptyItems++;
      index++;
    }
    if (emptyItems > 0) {
      var ending = emptyItems > 1 ? 's' : '';
      var message = '<' + emptyItems + ' empty item' + ending + '>';
      output.push(message);
    } else {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(index), true));
      index++;
    }
    visibleLength++;
  }
  var remaining = value.length - index;
  if (remaining > 0) {
    output.push('... ' + remaining + ' more item' + (remaining > 1 ? 's' : ''));
  }
  for (var n = 0; n < keys.length; n++) {
    var key = keys[n];
    if (typeof key === 'symbol' || !numbersOnlyRE.test(key)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  }
  return output;
}

function formatTypedArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var maxLength = Math.min(Math.max(0, ctx.maxArrayLength), value.length);
  var remaining = value.length - maxLength;
  var output = new Array(maxLength);
  for (var i = 0; i < maxLength; ++i) {
    output[i] = formatNumber(ctx, value[i]);
  }
  if (remaining > 0) {
    output.push('... ' + remaining + ' more item' + (remaining > 1 ? 's' : ''));
  }
  for (var key of keys) {
    if (typeof key === 'symbol' || !numbersOnlyRE.test(key)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  }
  return output;
}

function formatPromise(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  if (isPending(value)) {
    output.push('<pending>');
  } else {
    var nextRecurseTimes = recurseTimes === null ? null : recurseTimes - 1;
    var result = getPromiseResult(value);
    var str = formatValue(ctx, result, nextRecurseTimes);
    if (isRejected(value)) {
      output.push('<rejected> ' + str);
    } else {
      output.push(str);
    }
  }
  for (var n = 0; n < keys.length; n++) {
    output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, keys[n], false));
  }
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name = void 0,
      str = void 0,
      desc = void 0;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = '[Getter/Setter]';
    } else {
      str = '[Getter]';
    }
  } else {
    if (desc.set) {
      str = '[Setter]';
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    if (typeof key === 'symbol') {
      name = '[' + key.toString() + ']';
    } else {
      name = '[' + key + ']';
    }
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (recurseTimes === null) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.replace(/\n/g, '\n  ');
        } else {
          str = str.replace(/^|\n/g, '\n   ');
        }
      }
    } else {
      str = '[Circular]';
    }
  }
  if (name === undefined) {
    if (array && numbersOnlyRE.test(key)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (/^"[a-zA-Z_][a-zA-Z_0-9]*"$/.test(name)) {
      name = name.substr(1, name.length - 2);
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/^"|"$/g, "'").replace(/\\\\/g, '\\');
    }
  }
  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces, breakLength) {
  var length = output.reduce(function (prev, cur) {
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);
  if (length > breakLength) {
    return braces[0] + (
    // If the opening "brace" is too large, like in the case of "Set {",
    // we need to force the first item to be on the next line or the
    // items will not line up correctly.
    base === '' && braces[0].length === 1 ? '' : base + '\n ') + (' ' + output.join(',\n  ') + ' ' + braces[1]);
  }

  return '' + braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}

function hasOwnProperty(obj, prop) {
  return objectHasOwnProperty.call(obj, prop);
}

function isError(value) {
  return objectToString(value) === '[object Error]' || value instanceof Error;
}

function isDate(value) {
  return objectToString(value) === '[object Date]' || value instanceof Date;
}

function isPromise(value) {
  return objectToString(value) === '[object Promise]' || value instanceof Promise;
}

function isRegExp(value) {
  return objectToString(value) === '[object RegExp]' || value instanceof RegExp;
}

var typedArrayTypes = ['Float32Array', 'Float64Array', 'Int8Array', 'Int16Array', 'Int32Array', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array'];
var typedArrayNames = {};
for (var type of typedArrayTypes) {
  typedArrayNames['[object ' + type + ']'] = true;
}

function isTypedArray(value) {
  return typedArrayNames[objectToString(value)];
}

function isArrayBuffer(value) {
  return objectToString(value) === '[object ArrayBuffer]' || value instanceof ArrayBuffer;
}

function getConstructorOf(obj) {
  while (obj) {
    var descriptor = Object.getOwnPropertyDescriptor(obj, 'constructor');
    if (descriptor !== undefined && typeof descriptor.value === 'function' && descriptor.value.name !== '') {
      return descriptor.value;
    }
    obj = Object.getPrototypeOf(obj);
  }
  return null;
}

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

var defaultConsole = global.console.print ? createConsole(global.console) : global.console;

if (!defaultConsole.debug) {
  // The native node console has no "debug" method
  defaultConsole.debug = function () {
    defaultConsole.log(...arguments);
  };
}

var log = function () {
  defaultConsole.log(...arguments);
};
var warn = function () {
  defaultConsole.warn(...arguments);
};
var error = function () {
  defaultConsole.error(...arguments);
};

function createConsole(nativeConsole) {
  var console = {};

  var _loop = function (name) {
    console[name] = function () {
      nativeConsole.print(name, format(...arguments));
    };
  };

  for (var name of ['debug', 'info', 'log', 'warn', 'error']) {
    _loop(name);
  }
  return console;
}

function checkVersion(tabrisVersionString, clientVersionString) {
  if (!clientVersionString) {
    return;
  }
  var tabrisVersion = tabrisVersionString.split('.');
  var clientVersion = clientVersionString.split('.');
  if (tabrisVersion[0] !== clientVersion[0] || tabrisVersion[1] !== clientVersion[1]) {
    error('Version mismatch: JavaScript module "tabris" (version ' + tabrisVersionString + ') ' + ('is incompatible with the native tabris platform (version ' + clientVersionString + ').'));
  }
}

function omit(object, keys) {
  var result = {};
  for (var key in object) {
    if (!keys.includes(key)) {
      result[key] = object[key];
    }
  }
  return result;
}

function isObject(value) {
  return value !== null && typeof value === 'object';
}

function capitalizeFirstChar(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

function normalizePath(path) {
  if (typeof path !== 'string') {
    throw new Error('must be a string');
  }
  if (path === '') {
    throw new Error('must not be empty');
  }
  var prefix = path.startsWith('/') ? '/' : '';
  var result = prefix + path.split(/\/+/).map(function (segment) {
    if (segment === '..') {
      throw new Error("must not contain '..'");
    }
    return segment === '.' ? '' : segment;
  }).filter(function (string) {
    return !!string;
  }).join('/');
  return result ? result : '.';
}

function normalizePathUrl(url) {
  if (typeof url !== 'string') {
    throw new Error('must be a string');
  }
  var parts = /^([a-z-]+:(\/\/)?)?(.*)/.exec(url);
  var schema = parts[1] || '';
  var content = parts[3] || '';
  if (schema === 'data:') {
    return url;
  }
  return schema + normalizePath(content);
}

var EventObject = function () {
  function EventObject() {
    var _this = this;

    _classCallCheck(this, EventObject);

    this.$type = '';
    this.$target = null;
    Object.defineProperties(this, {
      type: { enumerable: true, get: function () {
          return _this.$type;
        } },
      target: { enumerable: true, get: function () {
          return _this.$target;
        } },
      timeStamp: { enumerable: true, value: Date.now() }
    });
  }

  _createClass(EventObject, [{
    key: 'preventDefault',
    value: function preventDefault() {
      this.$defaultPrevented = true;
    }
  }, {
    key: '_initEvent',
    value: function _initEvent(type, target) {
      if (arguments.length < 2) {
        throw new Error('Not enough arguments to initEvent');
      }
      this.$type = type;
      this.$target = target;
    }
  }, {
    key: 'defaultPrevented',
    get: function () {
      return !!this.$defaultPrevented;
    }
  }]);

  return EventObject;
}();

var Events = {
  on: function (type, callback, context) {
    if (isObject(type)) {
      for (var key in type) {
        this.on(key, type[key]);
      }
      return this;
    }
    var wasListening = this._isListening(type);
    this._callbacks = this._callbacks || [];
    this._callbacks[type] = (this._callbacks[type] || []).concat();
    var alreadyAdded = this._callbacks[type].some(function (entry) {
      return (entry.fn === callback || '_callback' in callback && entry.fn._callback === callback._callback) && entry.ctx === context;
    });
    if (!alreadyAdded) {
      this._callbacks[type].push({ fn: callback, ctx: context });
    }
    if (!wasListening) {
      this._listen(type, true);
    }
    return this;
  },
  off: function (type, callback, context) {
    if (isObject(type)) {
      for (var key in type) {
        this.off(key, type[key]);
      }
      return this;
    }
    if (!type || !callback) {
      throw new Error('Not enough arguments');
    }
    if (this._callbacks) {
      if (type in this._callbacks) {
        var callbacks = this._callbacks[type].concat();
        for (var i = callbacks.length - 1; i >= 0; i--) {
          if ((callbacks[i].fn === callback || callbacks[i].fn._callback === callback) && callbacks[i].ctx === context) {
            callbacks.splice(i, 1);
          }
        }
        if (callbacks.length === 0) {
          delete this._callbacks[type];
          if (Object.keys(this._callbacks).length === 0) {
            delete this._callbacks;
          }
        } else {
          this._callbacks[type] = callbacks;
        }
      }
    }
    if (!this._isListening(type)) {
      this._listen(type, false);
    }
    return this;
  },
  once: function (type, callback, context) {
    if (isObject(type)) {
      for (var key in type) {
        this.once(key, type[key]);
      }
      return this;
    }
    var self = this;
    var wrappedCallback = function () {
      if (!self._isDisposed) {
        self.off(type, wrappedCallback, context);
      }
      callback.apply(this, arguments);
    };
    wrappedCallback._callback = callback;
    return this.on(type, wrappedCallback, context);
  },
  trigger: function (type) {
    var event = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (!this._isDisposed) {
      if (this._callbacks && type in this._callbacks) {
        if (event instanceof EventObject) {
          event._initEvent(type, this);
        }
        var callbacks = this._callbacks[type];
        for (var i = 0; i < callbacks.length; i++) {
          var callback = callbacks[i];
          callback.fn.call(callback.ctx || this, event);
        }
      }
    }
    return this;
  },
  _isListening: function (type) {
    return !!this._callbacks && (!type || type in this._callbacks);
  },
  _listen: function () {}
};

function imageToArray(value) {
  return [value.src, checkValue(value.width), checkValue(value.height), checkValue(value.scale)];
}

function imageFromArray(value) {
  var result = { src: value[0] };
  if (value[1]) {
    result.width = value[1];
  }
  if (value[2]) {
    result.height = value[2];
  }
  if (value[3]) {
    result.scale = value[3];
  }
  return result;
}

function checkValue(value) {
  return value != null ? value : null;
}

function colorArrayToString(array) {
  var r = array[0];
  var g = array[1];
  var b = array[2];
  var a = array.length === 3 ? 1 : Math.round(array[3] * 100 / 255) / 100;
  return 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
}

function colorStringToArray(str) {
  if (str === 'transparent') {
    return [0, 0, 0, 0];
  }
  // #xxxxxx and #xxxxxxxx
  if (/^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})?$/.test(str)) {
    return [parseInt(RegExp.$1, 16), parseInt(RegExp.$2, 16), parseInt(RegExp.$3, 16), RegExp.$4 === '' ? 255 : parseInt(RegExp.$4, 16)];
  }
  // #xxx and #xxxx
  if (/^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])?$/.test(str)) {
    return [parseInt(RegExp.$1, 16) * 17, parseInt(RegExp.$2, 16) * 17, parseInt(RegExp.$3, 16) * 17, RegExp.$4 === '' ? 255 : parseInt(RegExp.$4, 16) * 17];
  }
  // #rgb(r, g, b)
  if (/^rgb\s*\(\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*\)$/.test(str)) {
    return [Math.max(0, Math.min(255, parseInt(RegExp.$1))), Math.max(0, Math.min(255, parseInt(RegExp.$2))), Math.max(0, Math.min(255, parseInt(RegExp.$3))), 255];
  }
  // rgba(r, g, b, a)
  if (/^rgba\s*\(\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*,\s*([+-]?[0-9]+)\s*,\s*([+-]?([0-9]*\.)?[0-9]+)\s*\)$/.test(str)) {
    return [Math.max(0, Math.min(255, parseInt(RegExp.$1))), Math.max(0, Math.min(255, parseInt(RegExp.$2))), Math.max(0, Math.min(255, parseInt(RegExp.$3))), Math.round(Math.max(0, Math.min(1, parseFloat(RegExp.$4))) * 255)];
  }
  // named colors
  if (str in NAMES) {
    var rgb = NAMES[str];
    return [rgb[0], rgb[1], rgb[2], 255];
  }
  throw new Error('invalid color: ' + str);
}

/*
 * Basic color keywords as defined in CSS 3
 * See http://www.w3.org/TR/css3-color/#html4
 */
var NAMES = {
  black: [0, 0, 0],
  silver: [192, 192, 192],
  gray: [128, 128, 128],
  white: [255, 255, 255],
  maroon: [128, 0, 0],
  red: [255, 0, 0],
  purple: [128, 0, 128],
  fuchsia: [255, 0, 255],
  green: [0, 128, 0],
  lime: [0, 255, 0],
  olive: [128, 128, 0],
  yellow: [255, 255, 0],
  navy: [0, 0, 128],
  blue: [0, 0, 255],
  teal: [0, 128, 128],
  aqua: [0, 255, 255]
};

function fontStringToObject(str) {
  var result = { family: [], size: 0, style: 'normal', weight: 'normal' };
  var parts = str.split(/(?:\s|^)\d+px(?:\s|$)/);
  checkTruthy(parts.length === 2 || parts.length === 1, 'Invalid font syntax');
  result.size = parseInt(/(?:\s|^)(\d+)px(?:\s|$)/.exec(str)[1], 10);
  parseStyles(result, parts[0]);
  parseFamily(result, parts[1]);
  return result;
}

function fontObjectToString(font) {
  return [font.style === 'normal' ? '' : font.style, font.weight === 'normal' ? '' : font.weight, font.size + 'px', font.family.join(', ')].filter(function (str) {
    return !!str;
  }).join(' ').trim();
}

function parseStyles(fontArr, styles) {
  var styleArr = styles.trim().split(/\s+/);
  checkTruthy(styleArr.length <= 2, 'Too many font styles');
  styleArr.forEach(function (property) {
    switch (property.trim()) {
      case 'italic':
        checkTruthy(fontArr.style === 'normal', 'Invalid font variant');
        fontArr.style = 'italic';
        break;
      case 'black':
      case 'bold':
      case 'medium':
      case 'thin':
      case 'light':
        checkTruthy(fontArr.weight === 'normal', 'Invalid font weight');
        fontArr.weight = property.trim();
        break;
      case 'normal':
      case '':
        break;
      default:
        throw new Error('Unknown font property: ' + property.trim());
    }
  });
}

function parseFamily(fontArr, family) {
  // NOTE: Currently family is optional to allow for default fonts, but this is
  //       not CSS font syntax. See https://github.com/eclipsesource/tabris-js/issues/24
  (family ? family.split(',') : []).forEach(function (name) {
    var valid = /(?:^\s*[^"']+\s*$)|(?:^\s*"[^"']+"\s*$)|(?:^\s*'[^"']+'\s*$)/.exec(name);
    checkTruthy(valid, 'Invalid font family: ' + name);
    fontArr.family.push(/^\s*["']?([^"']*)/.exec(name)[1].trim());
  });
}

function checkTruthy(value, message) {
  if (!value) {
    throw new Error(message);
  }
}

function EventsClass() {}
Object.assign(EventsClass.prototype, Events);

var NativeObject = function (_EventsClass) {
  _inherits(NativeObject, _EventsClass);

  _createClass(NativeObject, null, [{
    key: 'defineProperties',
    value: function defineProperties(target, definitions) {
      for (var name in definitions) {
        NativeObject.defineProperty(target, name, definitions[name]);
      }
    }
  }, {
    key: 'defineProperty',
    value: function defineProperty(target, name, definition) {
      target['$prop_' + name] = normalizeProperty(definition);
      Object.defineProperty(target, name, {
        set: function (value) {
          this.$setProperty(name, value);
        },
        get: function () {
          return this.$getProperty(name);
        }
      });
    }
  }, {
    key: 'extend',
    value: function extend(nativeType) {
      var superType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : NativeObject;

      return function (_superType) {
        _inherits(_class, _superType);

        function _class(properties) {
          _classCallCheck(this, _class);

          var _this3 = _possibleConstructorReturn(this, (_class.__proto__ || Object.getPrototypeOf(_class)).call(this));

          _this3._create(nativeType, properties || {});
          return _this3;
        }

        return _class;
      }(superType);
    }
  }]);

  function NativeObject() {
    _classCallCheck(this, NativeObject);

    var _this2 = _possibleConstructorReturn(this, (NativeObject.__proto__ || Object.getPrototypeOf(NativeObject)).call(this));

    if (!tabris._nativeBridge) {
      throw new Error('tabris.js not started');
    }
    if (_this2.constructor === NativeObject) {
      throw new Error('Cannot instantiate abstract NativeObject');
    }
    var cid = tabris._proxies.register(_this2);
    Object.defineProperty(_this2, 'cid', { value: cid });
    return _this2;
  }

  _createClass(NativeObject, [{
    key: 'set',
    value: function set(arg1, arg2) {
      if (typeof arg1 === 'string') {
        setExistingProperty.call(this, arg1, arg2);
      } else {
        this._reorderProperties(Object.keys(arg1)).forEach(function (name) {
          setExistingProperty.call(this, name, arg1[name]);
        }, this);
      }
      return this;
    }
  }, {
    key: 'get',
    value: function get(name) {
      return this[name];
    }
  }, {
    key: '$getProperty',
    value: function $getProperty(name) {
      if (this._isDisposed) {
        warn('Cannot get property "' + name + '" on disposed object');
        return;
      }
      var getter = this.$getPropertyGetter(name) || this._getStoredProperty;
      var value = getter.call(this, name);
      return this._decodeProperty(this._getTypeDef(name), value);
    }
  }, {
    key: '$setProperty',
    value: function $setProperty(name, value) {
      if (this._isDisposed) {
        warn('Cannot set property "' + name + '" on disposed object');
        return;
      }
      var typeDef = this._getTypeDef(name);
      var encodedValue = void 0;
      try {
        encodedValue = this._encodeProperty(typeDef, value);
      } catch (ex) {
        warn(this + ': Ignored unsupported value for property "' + name + '": ' + ex.message);
        return;
      }
      var setter = this.$getPropertySetter(name) || this._storeProperty;
      setter.call(this, name, encodedValue);
    }
  }, {
    key: '_storeProperty',
    value: function _storeProperty(name, encodedValue) {
      var oldEncodedValue = this._getStoredProperty(name);
      if (encodedValue === oldEncodedValue) {
        return;
      }
      if (encodedValue === undefined && this._props) {
        delete this._props[name];
      } else {
        if (!this._props) {
          this._props = {};
        }
        this._props[name] = encodedValue;
      }
      this._triggerChangeEvent(name, encodedValue);
    }
  }, {
    key: '_getStoredProperty',
    value: function _getStoredProperty(name) {
      var result = this._props ? this._props[name] : undefined;
      if (result === undefined) {
        result = this._getDefaultPropertyValue(name);
      }
      return result;
    }
  }, {
    key: '_getTypeDef',
    value: function _getTypeDef(name) {
      var prop = this['$prop_' + name];
      return prop ? prop.type : null;
    }
  }, {
    key: '_getDefaultPropertyValue',
    value: function _getDefaultPropertyValue(name) {
      var prop = this['$prop_' + name];
      return prop ? valueOf(prop.default) : undefined;
    }
  }, {
    key: '_encodeProperty',
    value: function _encodeProperty(typeDef, value) {
      return typeDef && typeDef.encode ? typeDef.encode(value) : value;
    }
  }, {
    key: '_decodeProperty',
    value: function _decodeProperty(typeDef, value) {
      return typeDef && typeDef.decode ? typeDef.decode(value) : value;
    }
  }, {
    key: '$getPropertyGetter',
    value: function $getPropertyGetter(name) {
      var prop = this['$prop_' + name];
      return prop ? prop.get : undefined;
    }
  }, {
    key: '$getPropertySetter',
    value: function $getPropertySetter(name) {
      var prop = this['$prop_' + name];
      return prop ? prop.set : undefined;
    }
  }, {
    key: '_triggerChangeEvent',
    value: function _triggerChangeEvent(propertyName, newEncodedValue) {
      var typeDef = this._getTypeDef(propertyName);
      var decodedValue = this._decodeProperty(typeDef, newEncodedValue);
      this.$trigger(propertyName + 'Changed', { value: decodedValue });
    }
  }, {
    key: '_create',
    value: function _create(type) {
      var properties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      tabris._nativeBridge.create(this.cid, type);
      this._reorderProperties(Object.keys(properties)).forEach(function (name) {
        setExistingProperty.call(this, name, properties[name]);
      }, this);
      return this;
    }
  }, {
    key: '_reorderProperties',
    value: function _reorderProperties(properties) {
      return properties;
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      this._dispose();
    }
  }, {
    key: '_dispose',
    value: function _dispose(skipNative) {
      if (!this._isDisposed && !this._inDispose) {
        this._inDispose = true;
        this._trigger('dispose');
        this._release();
        if (!skipNative) {
          tabris._nativeBridge.destroy(this.cid);
        }
        tabris._proxies.remove(this.cid);
        delete this._props;
        this._isDisposed = true;
      }
    }
  }, {
    key: '_release',
    value: function _release() {}
  }, {
    key: 'isDisposed',
    value: function isDisposed() {
      return !!this._isDisposed;
    }
  }, {
    key: '_listen',
    value: function _listen() /* name, listening */{}
  }, {
    key: '_nativeListen',
    value: function _nativeListen(event, state) {
      this._checkDisposed();
      tabris._nativeBridge.listen(this.cid, event, state);
    }
  }, {
    key: '_trigger',
    value: function _trigger(name) {
      var eventData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      return this.$trigger(name, eventData);
    }
  }, {
    key: '$trigger',
    value: function $trigger(name) {
      var eventData = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var event = new EventObject();
      for (var key in eventData) {
        if (!(key in event)) {
          Object.defineProperty(event, key, { enumerable: true, value: eventData[key] });
        }
      }
      this.trigger(name, event);
      return !!event.defaultPrevented;
    }
  }, {
    key: '_onoff',
    value: function _onoff(name, listening, listener) {
      listening ? this.on(name, listener) : this.off(name, listener);
    }
  }, {
    key: '_checkDisposed',
    value: function _checkDisposed() {
      if (this._isDisposed) {
        throw new Error('Object is disposed');
      }
    }
  }, {
    key: '_nativeSet',
    value: function _nativeSet(name, value) {
      this._checkDisposed();
      tabris._nativeBridge.set(this.cid, name, value);
    }
  }, {
    key: '_nativeGet',
    value: function _nativeGet(name) {
      this._checkDisposed();
      return tabris._nativeBridge.get(this.cid, name);
    }
  }, {
    key: '_nativeCall',
    value: function _nativeCall(method, parameters) {
      this._checkDisposed();
      return tabris._nativeBridge.call(this.cid, method, parameters);
    }
  }, {
    key: 'toString',
    value: function toString() {
      return this.constructor.name;
    }
  }]);

  return NativeObject;
}(EventsClass);

function setExistingProperty(name, value) {
  if (name in this) {
    this[name] = value;
  } else {
    warn('Unknown property "' + name + '"');
  }
}

function normalizeProperty(property) {
  var config = typeof property === 'string' ? { type: property } : property;
  return {
    type: resolveType(config.type || 'any'),
    default: config.default,
    nocache: config.nocache,
    set: config.readonly && readOnlySetter || config.set || defaultSetter,
    get: config.get || defaultGetter
  };
}

function resolveType(type) {
  var typeDef = type;
  if (typeof type === 'string') {
    typeDef = types[type];
  } else if (Array.isArray(type)) {
    typeDef = types[type[0]];
  }
  if (typeof typeDef !== 'object') {
    throw new Error('Can not find property type ' + type);
  }
  if (Array.isArray(type)) {
    typeDef = Object.assign({}, typeDef);
    var args = type.slice(1);
    if (typeDef.encode) {
      typeDef.encode = wrapCoder(typeDef.encode, args);
    }
    if (typeDef.decode) {
      typeDef.decode = wrapCoder(typeDef.decode, args);
    }
  }
  return typeDef;
}

function wrapCoder(fn, args) {
  return function (value) {
    return fn.apply(global, [value].concat(args));
  };
}

function readOnlySetter(name) {
  warn('Can not set read-only property "' + name + '"');
}

function defaultSetter(name, value) {
  this._nativeSet(name, value === undefined ? null : value);
  if (this['$prop_' + name].nocache) {
    this._triggerChangeEvent(name, value);
  } else {
    this._storeProperty(name, value);
  }
}

function defaultGetter(name) {
  var result = this._getStoredProperty(name);
  if (result === undefined) {
    // TODO: cache read property, but not for device properties
    result = this._nativeGet(name);
  }
  return result;
}

function valueOf(value) {
  return value instanceof Function ? value() : value;
}

var WidgetCollection = function () {
  function WidgetCollection(collection, selector, deep) {
    _classCallCheck(this, WidgetCollection);

    var arr = collection instanceof WidgetCollection ? collection.toArray() : collection;
    this._array = select(arr, selector || '*', deep);
    for (var i = 0; i < this._array.length; i++) {
      this[i] = this._array[i];
    }
  }

  _createClass(WidgetCollection, [{
    key: 'first',
    value: function first(selector) {
      if (selector) {
        return this.filter(selector).first();
      }
      return this._array[0];
    }
  }, {
    key: 'last',
    value: function last(selector) {
      if (selector) {
        return this.filter(selector).last();
      }
      return this._array[this._array.length - 1];
    }
  }, {
    key: 'toArray',
    value: function toArray() {
      return this._array.concat();
    }
  }, {
    key: 'forEach',
    value: function forEach(callback) {
      var _this4 = this;

      this._array.forEach(function (value, index) {
        return callback(value, index, _this4);
      });
    }
  }, {
    key: 'indexOf',
    value: function indexOf(needle) {
      return this._array.indexOf(needle);
    }
  }, {
    key: 'includes',
    value: function includes(needle) {
      return this._array.indexOf(needle) !== -1;
    }
  }, {
    key: 'filter',
    value: function filter(selector) {
      return new WidgetCollection(this._array, selector);
    }
  }, {
    key: 'get',
    value: function get(prop) {
      if (this._array[0]) {
        return this._array[0].get(prop);
      }
    }
  }, {
    key: 'parent',
    value: function parent() {
      var result = [];
      for (var widget of this._array) {
        var parent = widget.parent();
        if (parent && result.indexOf(parent) === -1) {
          result.push(parent);
        }
      }
      if (result.length) {
        return new WidgetCollection(result);
      }
    }
  }, {
    key: 'children',
    value: function children(selector) {
      var result = [];
      for (var widget of this._array) {
        result.push.apply(result, widget.children());
      }
      return new WidgetCollection(result, selector);
    }
  }, {
    key: 'find',
    value: function find(selector) {
      return new WidgetCollection(this.children()._array, selector, true);
    }
  }, {
    key: 'appendTo',
    value: function appendTo(parent) {
      parent.append(this);
    }
  }, {
    key: 'set',
    value: function set() {
      var _arguments = arguments;

      this._array.forEach(function (widget) {
        return widget.set.apply(widget, _arguments);
      });
      return this;
    }
  }, {
    key: 'on',
    value: function on() {
      var _arguments2 = arguments;

      this._array.forEach(function (widget) {
        return widget.on.apply(widget, _arguments2);
      });
      return this;
    }
  }, {
    key: 'off',
    value: function off() {
      var _arguments3 = arguments;

      this._array.forEach(function (widget) {
        return widget.off.apply(widget, _arguments3);
      });
      return this;
    }
  }, {
    key: 'once',
    value: function once() {
      var _arguments4 = arguments;

      this._array.forEach(function (widget) {
        return widget.once.apply(widget, _arguments4);
      });
      return this;
    }
  }, {
    key: 'trigger',
    value: function trigger() {
      var _arguments5 = arguments;

      this._array.forEach(function (widget) {
        return widget.trigger.apply(widget, _arguments5);
      });
      return this;
    }
  }, {
    key: 'animate',
    value: function animate() {
      var _arguments6 = arguments;

      this._array.forEach(function (widget) {
        return widget.animate.apply(widget, _arguments6);
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      var _arguments7 = arguments;

      this._array.forEach(function (widget) {
        return widget.dispose.apply(widget, _arguments7);
      });
    }
  }, {
    key: Symbol.iterator,
    value: function () {
      var _this5 = this;

      var index = 0;
      return {
        next: function () {
          return index < _this5.length ? { value: _this5[index++], done: false } : { done: true };
        }
      };
    }
  }, {
    key: 'length',
    get: function () {
      return this._array.length;
    }
  }]);

  return WidgetCollection;
}();

function select(array, selector, deep) {
  if (!array || array.length === 0) {
    return [];
  }
  if (selector === '*' && !deep) {
    return array.concat();
  }
  var filter = getFilter(selector);
  if (deep) {
    return deepSelect([], array, filter);
  }
  return array.filter(filter);
}

function deepSelect(result, iterable, filter) {
  for (var widget of iterable) {
    if (filter(widget)) {
      result.push(widget);
    }
    var children = widget.children();
    if (children instanceof WidgetCollection && children.length) {
      deepSelect(result, children, filter);
    }
  }
  return result;
}

function getFilter(selector) {
  var matches = {};
  var filter = isFilter(selector) ? selector : createMatcher(selector);
  return function (widget) {
    if (matches[widget.cid]) {
      return false;
    }
    if (filter(widget)) {
      matches[widget.cid] = true;
      return true;
    }
    return false;
  };
}

function createMatcher(selector) {
  if (selector instanceof Function) {
    return function (widget) {
      return widget instanceof selector;
    };
  }
  if (selector.charAt(0) === '#') {
    var expectedId = selector.slice(1);
    return function (widget) {
      return expectedId === widget.id;
    };
  }
  if (selector.charAt(0) === '.') {
    var expectedClass = selector.slice(1);
    return function (widget) {
      return widget.classList.indexOf(expectedClass) !== -1;
    };
  }
  if (selector === '*') {
    return function () {
      return true;
    };
  }
  return function (widget) {
    return selector === widget.constructor.name;
  };
}

function isFilter(selector) {
  return selector instanceof Function && !isWidgetConstructor(selector);
}

function isWidgetConstructor(fn) {
  var proto = fn.prototype;
  while (proto) {
    // Use NativeObject since importing Widget would causes circulary module dependency issues
    if (proto === NativeObject.prototype) {
      return true;
    }
    proto = Object.getPrototypeOf(proto);
  }
  return false;
}

var types = {

  any: {},

  boolean: {
    encode: function (bool) {
      return !!bool;
    }
  },

  string: {
    encode: function (str) {
      return str == null ? '' : '' + str;
    }
  },

  number: {
    encode: function (value) {
      return encodeNumber(value);
    }
  },

  natural: {
    encode: function (value) {
      value = encodeNumber(value);
      return value < 0 ? 0 : Math.round(value);
    }
  },

  integer: {
    encode: function (value) {
      value = encodeNumber(value);
      return Math.round(value);
    }
  },

  function: {
    encode: function (value) {
      if ('function' !== typeof value) {
        throw new Error(typeof value + ' is not a function: ' + value);
      }
      return value;
    }
  },

  choice: {
    encode: function (value, acceptable) {
      if (acceptable.indexOf(value) === -1) {
        throwNotAcceptedError(acceptable, value);
      }
      return value;
    }
  },

  color: {
    encode: function (value) {
      if (value === null || value === 'initial') {
        return undefined;
      }
      return colorStringToArray(value);
    },
    decode: function (value) {
      if (!value) {
        // NOTE: null is only returned for "background" where it means "no background"
        return 'rgba(0, 0, 0, 0)';
      }
      return colorArrayToString(value);
    }
  },

  font: {
    encode: function (value) {
      if (value === null || value === 'initial') {
        return undefined;
      }
      return fontStringToObject(value);
    },
    decode: function (value) {
      if (!value) {
        // NOTE: workaround to allow triggering a change event when setting font to "initial"
        return 'initial';
      }
      return fontObjectToString(value);
    }
  },

  boxDimensions: {
    encode: function (value) {
      if (value === 'initial') {
        return undefined;
      }
      if (value === null || typeof value === 'number') {
        return { left: value || 0, right: value || 0, top: value || 0, bottom: value || 0 };
      }
      if (typeof value === 'object') {
        return value;
      }
      throw new Error('Invalid type: ' + value);
    }
  },

  image: {
    encode: function (value) {
      if (!value) {
        return null;
      }
      if (typeof value === 'string') {
        value = { src: value };
      }
      if (typeof value !== 'object') {
        throw new Error('Not an image: ' + value);
      }
      try {
        value.src = normalizePathUrl(value.src);
      } catch (err) {
        throw new Error('Invalid image.src: ' + err.message);
      }
      ['scale', 'width', 'height'].forEach(function (prop) {
        if (prop in value && !isDimension(value[prop])) {
          throw new Error('image.' + prop + ' is not a dimension: ' + value[prop]);
        }
      });
      if ('scale' in value && ('width' in value || 'height' in value)) {
        warn('Image scale is ignored if width or height are given');
      }
      return imageToArray(value);
    },
    decode: function (value) {
      if (!value) {
        return null;
      }
      return imageFromArray(value);
    }
  },

  layoutData: {
    encode: function (value) {
      return encodeLayoutData(value);
    },
    decode: function (value) {
      return decodeLayoutData(value);
    }
  },

  edge: {
    encode: function (value) {
      return value == null ? null : encodeEdge(value);
    },

    decode: decodeLayoutAttr
  },

  dimension: {
    encode: function (value) {
      return value == null ? null : encodeNumber(value);
    },

    decode: decodeLayoutAttr
  },

  sibling: {
    encode: function (value) {
      return value == null ? null : encodeWidgetRef(value);
    },

    decode: decodeLayoutAttr
  },

  bounds: {
    encode: function (value) {
      return [value.left, value.top, value.width, value.height];
    },
    decode: function (value) {
      return { left: value[0], top: value[1], width: value[2], height: value[3] };
    }
  },

  proxy: {
    encode: function (value) {
      if (value instanceof NativeObject) {
        return value.cid;
      }
      if (value instanceof WidgetCollection) {
        return value[0] ? value[0].cid : null;
      }
      // TODO: Should throw error instead
      return value;
    },
    decode: function (cid) {
      return tabris._proxies.find(cid);
    }
  },

  nullable: {
    encode: function (value, altCheck) {
      if (value === null) {
        return value;
      }
      return types[altCheck].encode(value);
    }
  },

  opacity: {
    encode: function (value) {
      value = encodeNumber(value);
      return Math.max(0, Math.min(1, value));
    }
  },

  transform: {
    encode: function (value) {
      var result = Object.assign({}, transformDefaults);
      for (var key in value) {
        if (!(key in transformDefaults)) {
          throw new Error('Not a valid transformation containing "' + key + '"');
        }
        result[key] = encodeNumber(value[key]);
      }
      return result;
    }
  },

  array: {
    encode: function (value, type) {
      if (value == null) {
        return [];
      }
      if (!(value instanceof Array)) {
        throw new Error(typeof value + ' is not an array: ' + value);
      }
      if (type) {
        return value.map(types[type].encode);
      }
      return value;
    }
  }

};

var numberRegex = /^[+-]?([0-9]+|[0-9]*\.[0-9]+)$/;
var selectorRegex = /^(\*|prev\(\)|next\(\)|([#.]?[A-Za-z_][A-Za-z0-9_-]+))$/;

function isDimension(value) {
  return typeof value === 'number' && !isNaN(value) && value >= 0 && value !== Infinity;
}

function throwNotAcceptedError(acceptable, given) {
  var message = ['Accepting "'];
  message.push(acceptable.join('", "'));
  message.push('", given was: "', given + '"');
  throw new Error(message.join(''));
}

function encodeNumber(value) {
  if (typeof value === 'string' && numberRegex.test(value)) {
    return parseFloat(value);
  }
  if (typeof value !== 'number') {
    throw new Error('Not a number: ' + toString(value));
  }
  if (!isFinite(value)) {
    throw new Error('Invalid number: ' + toString(value));
  }
  return value;
}

var transformDefaults = {
  rotation: 0,
  scaleX: 1,
  scaleY: 1,
  translationX: 0,
  translationY: 0,
  translationZ: 0
};

var layoutEncoders = {
  width: encodeNumber,
  height: encodeNumber,
  left: encodeEdge,
  right: encodeEdge,
  top: encodeEdge,
  bottom: encodeEdge,
  centerX: encodeNumber,
  centerY: encodeNumber,
  baseline: encodeWidgetRef
};

function encodeLayoutData(layoutData) {
  var result = {};
  for (var key in layoutData) {
    if (layoutData[key] != null) {
      if (!(key in layoutEncoders)) {
        throw new Error("Invalid key '" + key + "' in layoutData");
      }
      try {
        result[key] = layoutEncoders[key](layoutData[key]);
      } catch (error$$1) {
        throw new Error("Invalid value for '" + key + "': " + error$$1.message);
      }
    }
  }
  return result;
}

function encodeEdge(value) {
  if (typeof value === 'string') {
    if (value.indexOf(' ') !== -1) {
      return encodeEdgeArray(value.split(/\s+/));
    }
    if (value[value.length - 1] === '%') {
      var percentage = encodePercentage(value);
      return percentage === 0 ? 0 : [percentage, 0];
    }
    if (numberRegex.test(value)) {
      return [0, parseFloat(value)];
    }
    if (selectorRegex.test(value)) {
      return [value, 0];
    }
    throw new Error('Invalid dimension: ' + toString(value));
  }
  if (typeof value === 'number') {
    if (!isFinite(value)) {
      throw new Error('Invalid number: ' + toString(value));
    }
    return value;
  }
  if (Array.isArray(value)) {
    return encodeEdgeArray(value);
  }
  if (value instanceof NativeObject) {
    return [value, 0];
  }
  throw new Error('Invalid dimension: ' + toString(value));
}

function encodeEdgeArray(array) {
  if (array.length !== 2) {
    throw new Error('Wrong number of elements (must be 2): ' + toString(array));
  }
  var ref = encodeEdgeRef(array[0]);
  var offset = encodeNumber(array[1]);
  return ref === 0 ? offset : [ref, offset];
}

function encodeEdgeRef(value) {
  if (typeof value === 'string') {
    if (value[value.length - 1] === '%') {
      return encodePercentage(value);
    }
    if (selectorRegex.test(value)) {
      return value;
    }
  }
  if (typeof value === 'number') {
    if (!isFinite(value)) {
      throw new Error('Invalid number: ' + toString(value));
    }
    return value;
  }
  if (value instanceof NativeObject) {
    return value;
  }
  throw new Error('Not a percentage or widget reference: ' + toString(value));
}

function encodePercentage(value) {
  var sub = value.substr(0, value.length - 1);
  if (numberRegex.test(sub)) {
    return parseFloat(sub);
  }
  throw new Error('Invalid percentage value: ' + toString(value));
}

function encodeWidgetRef(value) {
  if (value instanceof NativeObject) {
    return value;
  }
  if (typeof value === 'string' && selectorRegex.test(value)) {
    return value;
  }
  throw new Error('Not a widget reference: ' + toString(value));
}

function decodeLayoutData(layoutData) {
  if (!layoutData) {
    return null;
  }
  var result = {};
  for (var key in layoutData) {
    result[key] = decodeLayoutAttr(layoutData[key]);
  }
  return result;
}

function decodeLayoutAttr(value) {
  if (Array.isArray(value)) {
    if (value[0] === 0) {
      return value[1];
    }
    if (value[1] === 0) {
      return typeof value[0] === 'number' ? value[0] + '%' : value[0];
    }
    return [typeof value[0] === 'number' ? value[0] + '%' : value[0], value[1]];
  }
  return value;
}

function toString(value) {
  if (typeof value === 'string') {
    return "'" + value + "'";
  }
  if (Array.isArray(value)) {
    return '[' + value.map(toString).join(', ') + ']';
  }
  if (typeof value === 'object' && value != null) {
    return '{' + Object.keys(value).join(', ') + '}';
  }
  return '' + value;
}

var Layout = {
  checkConsistency: function (layoutData) {
    var result = layoutData;
    if ('centerX' in result) {
      if ('left' in result || 'right' in result) {
        warn('Inconsistent layoutData: centerX overrides left and right');
        result = omit(result, ['left', 'right']);
      }
    }
    if ('baseline' in result) {
      if ('top' in result || 'bottom' in result || 'centerY' in result) {
        warn('Inconsistent layoutData: baseline overrides top, bottom, and centerY');
        result = omit(result, ['top', 'bottom', 'centerY']);
      }
    } else if ('centerY' in result) {
      if ('top' in result || 'bottom' in result) {
        warn('Inconsistent layoutData: centerY overrides top and bottom');
        result = omit(result, ['top', 'bottom']);
      }
    }
    if ('left' in result && 'right' in result && 'width' in result) {
      warn('Inconsistent layoutData: left and right are set, ignore width');
      result = omit(result, ['width']);
    }
    if ('top' in result && 'bottom' in result && 'height' in result) {
      warn('Inconsistent layoutData: top and bottom are set, ignore height');
      result = omit(result, ['height']);
    }
    return result;
  },
  resolveReferences: function (layoutData, targetWidget) {
    var result = {};
    for (var key in layoutData) {
      result[key] = resolveAttribute(layoutData[key], targetWidget);
    }
    return result;
  },
  addToQueue: function (parent) {
    layoutQueue[parent.cid] = parent;
  },
  flushQueue: function () {
    for (var cid in layoutQueue) {
      layoutQueue[cid]._flushLayout();
    }
    layoutQueue = {};
  }
};

var layoutQueue = {};

function resolveAttribute(value, widget) {
  if (Array.isArray(value)) {
    return resolveArray(value, widget);
  }
  if (isNumber(value)) {
    return value;
  }
  return toProxyId(value, widget);
}

function resolveArray(array, widget) {
  if (isNumber(array[0])) {
    return array;
  }
  return [toProxyId(array[0], widget), array[1]];
}

function toProxyId(ref, widget) {
  if (ref === 'prev()') {
    var children = getParent(widget)._children();
    var index = children.indexOf(widget);
    if (index > 0) {
      return types.proxy.encode(children[index - 1]) || 0;
    }
    return 0;
  }
  if (ref === 'next()') {
    var _children = getParent(widget)._children();
    var _index = _children.indexOf(widget);
    if (_index + 1 < _children.length) {
      return types.proxy.encode(_children[_index + 1]) || 0;
    }
    return 0;
  }
  if (typeof ref === 'string') {
    var proxy = widget.siblings(ref)[0];
    return types.proxy.encode(proxy) || 0;
  }
  if (widget.siblings().toArray().includes(ref)) {
    return types.proxy.encode(ref) || 0;
  }
  return 0;
}

function isNumber(value) {
  return typeof value === 'number' && isFinite(value);
}

function getParent(widget) {
  return widget.parent() || emptyParent;
}

var emptyParent = {
  children: function () {
    return [];
  }
};

var NativeBridge = function () {
  function NativeBridge(bridge) {
    _classCallCheck(this, NativeBridge);

    this.$bridge = bridge;
    this.$operations = [];
    this.$currentOperation = { id: null };
    tabris.on('flush', this.flush, this);
  }

  _createClass(NativeBridge, [{
    key: 'create',
    value: function create(id, type) {
      var properties = {};
      this.$operations.push(['create', id, type, properties]);
      this.$currentOperation = { id: id, properties: properties };
    }
  }, {
    key: 'set',
    value: function set(id, name, value) {
      if (this.$currentOperation.id === id) {
        this.$currentOperation.properties[name] = value;
      } else {
        var properties = {};
        properties[name] = value;
        this.$operations.push(['set', id, properties]);
        this.$currentOperation = { id: id, properties: properties };
      }
    }
  }, {
    key: 'listen',
    value: function listen(id, event, _listen2) {
      this.$operations.push(['listen', id, event, _listen2]);
      this.$currentOperation = { id: null };
    }
  }, {
    key: 'destroy',
    value: function destroy(id) {
      this.$operations.push(['destroy', id]);
      this.$currentOperation = { id: null };
    }
  }, {
    key: 'get',
    value: function get(id, name) {
      this.flush();
      return this.$bridge.get(id, name);
    }
  }, {
    key: 'call',
    value: function call(id, method, parameters) {
      this.flush();
      return this.$bridge.call(id, method, parameters);
    }
  }, {
    key: 'flush',
    value: function flush() {
      Layout.flushQueue();
      var operations = this.$operations;
      this.$operations = [];
      this.$currentOperation = { id: null };
      var length = operations.length;
      // Using apply() on the native bridge does not work with Rhino. It seems that the parameter
      // count must be known in order to find the associated native method.
      for (var i = 0; i < length; i++) {
        var op = operations[i];
        switch (op[0]) {
          case 'create':
            this.$bridge.create(op[1], op[2], op[3]);
            break;
          case 'set':
            this.$bridge.set(op[1], op[2]);
            break;
          case 'listen':
            this.$bridge.listen(op[1], op[2], op[3]);
            break;
          case 'destroy':
            this.$bridge.destroy(op[1]);
        }
      }
    }
  }]);

  return NativeBridge;
}();

var ProxyStore = function () {
  function ProxyStore() {
    _classCallCheck(this, ProxyStore);

    this.$idSequence = 1;
    this.$proxies = {};
  }

  _createClass(ProxyStore, [{
    key: 'register',
    value: function register(proxy) {
      var cid = this.$generateId();
      if (cid in this.$proxies) {
        throw new Error('cid already in use: ' + cid);
      }
      this.$proxies[cid] = proxy;
      return cid;
    }
  }, {
    key: 'remove',
    value: function remove(cid) {
      delete this.$proxies[cid];
    }
  }, {
    key: 'find',
    value: function find(cid) {
      return this.$proxies[cid] || null;
    }
  }, {
    key: '$generateId',
    value: function $generateId() {
      return 'o' + this.$idSequence++;
    }
  }]);

  return ProxyStore;
}();

var Tabris = function () {
  function Tabris() {
    _classCallCheck(this, Tabris);

    this._started = false;
    this._init = this._init.bind(this);
    this._notify = this._notify.bind(this);
  }

  _createClass(Tabris, [{
    key: '_init',
    value: function _init(client) {
      this._client = client;
      this._proxies = new ProxyStore();
      this._nativeBridge = new NativeBridge(client);
      this.trigger('start');
      this._started = true;
    }
  }, {
    key: '_setEntryPoint',
    value: function _setEntryPoint(entryPoint) {
      this._entryPoint = entryPoint;
    }
  }, {
    key: '_notify',
    value: function _notify(cid, event, param) {
      var returnValue = void 0;
      try {
        var proxy = this._proxies.find(cid);
        if (proxy) {
          try {
            returnValue = proxy._trigger(event, param);
          } catch (err) {
            error(err);
          }
        }
        this.trigger('flush');
      } catch (err) {
        error(err);
      }
      return returnValue;
    }
  }, {
    key: 'version',
    get: function () {
      return '2.4.2';
    }
  }, {
    key: 'started',
    get: function () {
      return !!this._started;
    }
  }]);

  return Tabris;
}();

Object.assign(Tabris.prototype, Events);

var Device = function (_NativeObject) {
  _inherits(Device, _NativeObject);

  function Device() {
    _classCallCheck(this, Device);

    var _this6 = _possibleConstructorReturn(this, (Device.__proto__ || Object.getPrototypeOf(Device)).call(this));

    if (arguments[0] !== true) {
      throw new Error('Device can not be created');
    }
    _this6._create('tabris.Device');
    return _this6;
  }

  _createClass(Device, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'orientationChanged') {
        this._nativeListen(name, listening);
      } else {
        _get(Device.prototype.__proto__ || Object.getPrototypeOf(Device.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'orientationChanged') {
        this._triggerChangeEvent('orientation', event.orientation);
      } else {
        _get(Device.prototype.__proto__ || Object.getPrototypeOf(Device.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      throw new Error('Cannot dispose device object');
    }
  }]);

  return Device;
}(NativeObject);

NativeObject.defineProperties(Device.prototype, {
  model: { readonly: true, get: getOnce },
  vendor: { readonly: true, get: getOnce },
  platform: { readonly: true, get: getOnce },
  version: { readonly: true, get: getOnce },
  language: { readonly: true },
  orientation: { readonly: true },
  screenWidth: { readonly: true },
  screenHeight: { readonly: true },
  scaleFactor: { readonly: true, get: getOnce },
  win_keyboardPresent: { readonly: true },
  win_primaryInput: { readonly: true }
});

function create() {
  return new Device(true);
}

function publishDeviceProperties(device, target) {
  target.devicePixelRatio = device.scaleFactor;
  target.device = createDevice(device);
  target.screen = createScreen(device);
  target.navigator = createNavigator(device);
}

function createDevice(device) {
  var dev = {};
  ['model', 'vendor', 'platform', 'version'].forEach(function (name) {
    defineReadOnlyProperty(dev, name, function () {
      return device[name];
    });
  });
  return dev;
}

function createScreen(device) {
  var screen = {};
  defineReadOnlyProperty(screen, 'width', function () {
    return device.screenWidth;
  });
  defineReadOnlyProperty(screen, 'height', function () {
    return device.screenHeight;
  });
  return screen;
}

function createNavigator(device) {
  var navigator = {};
  defineReadOnlyProperty(navigator, 'userAgent', function () {
    return 'tabris-js';
  });
  defineReadOnlyProperty(navigator, 'language', function () {
    return device.language;
  });
  return navigator;
}

function defineReadOnlyProperty(target, name, getter) {
  Object.defineProperty(target, name, {
    get: getter,
    set: function () {}
  });
}

function getOnce(name) {
  var value = this._getStoredProperty(name);
  if (!value) {
    value = this._nativeGet(name);
    this._storeProperty(name, value);
  }
  return value;
}

var Printer = function (_NativeObject2) {
  _inherits(Printer, _NativeObject2);

  function Printer() {
    _classCallCheck(this, Printer);

    var _this7 = _possibleConstructorReturn(this, (Printer.__proto__ || Object.getPrototypeOf(Printer)).call(this));

    if (arguments[0] !== true) {
      throw new Error('Printer can not be created');
    }
    _this7._create('tabris.Printer');
    return _this7;
  }

  _createClass(Printer, [{
    key: 'print',
    value: function print(data, options) {
      var _arguments8 = arguments,
          _this8 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments8.length < 1) {
          throw new Error('Not enough arguments to print');
        }
        if (!isDataValid(data)) {
          throw new Error('data is not an ArrayBuffer or typed array');
        }
        _this8._nativeCall('print', {
          data: data instanceof ArrayBuffer ? data : data.buffer,
          options: options,
          onResult: function (result) {
            return resolve({ result: result });
          },
          onError: function (error) {
            return reject(new Error(error));
          }
        });
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      throw new Error('Cannot dispose printer object');
    }
  }]);

  return Printer;
}(NativeObject);

function isDataValid(value) {
  return value instanceof ArrayBuffer || value instanceof Int8Array || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int16Array || value instanceof Uint16Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Float32Array || value instanceof Float64Array;
}

function create$1() {
  return new Printer(true);
}

var CERTIFICATE_ALGORITHMS = ['RSA2048', 'RSA4096', 'ECDSA256'];
var EVENT_TYPES = ['foreground', 'background', 'pause', 'resume', 'terminate', 'backNavigation', 'certificatesReceived'];

var App = function (_NativeObject3) {
  _inherits(App, _NativeObject3);

  function App() {
    _classCallCheck(this, App);

    var _this9 = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this));

    if (arguments[0] !== true) {
      throw new Error('App can not be created');
    }
    _this9._create('tabris.App');
    return _this9;
  }

  _createClass(App, [{
    key: 'launch',
    value: function launch(url) {
      var _arguments9 = arguments,
          _this10 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments9.length < 1) {
          throw new Error('Not enough arguments to launch');
        }
        if (typeof url !== 'string') {
          throw new Error('url is not a string');
        }
        _this10._nativeCall('launch', {
          url: url,
          onError: function (err) {
            return reject(new Error(err));
          },
          onSuccess: function () {
            return resolve();
          }
        });
      });
    }
  }, {
    key: 'getResourceLocation',
    value: function getResourceLocation(path) {
      if (!this._resourceBaseUrl) {
        this._resourceBaseUrl = this._nativeGet('resourceBaseUrl');
      }
      var subPath = path != null ? '/' + normalizePath$1('' + path) : '';
      return this._resourceBaseUrl + subPath;
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      throw new Error('tabris.app can not be disposed');
    }
  }, {
    key: 'reload',
    value: function reload() {
      this._nativeCall('reload', {});
    }
  }, {
    key: 'close',
    value: function close() {
      this._nativeCall('close');
    }
  }, {
    key: 'registerFont',
    value: function registerFont(alias, file) {
      if (arguments.length < 2) {
        throw new Error('Not enough arguments to register a font');
      }
      if (typeof alias !== 'string') {
        throw new Error('alias is not a string');
      }
      if (typeof file !== 'string') {
        throw new Error('file is not a string');
      }
      this._nativeCall('registerFont', { alias: alias, file: file });
    }
  }, {
    key: 'installPatch',
    value: function installPatch(url, callback) {
      if (typeof url !== 'string') {
        throw new Error('parameter url is not a string');
      }
      if (!this._pendingPatchCallback) {
        this._pendingPatchCallback = callback || true;
        this._nativeListen('patchInstall', true);
        this._nativeCall('installPatch', { url: url });
      } else if (typeof callback === 'function') {
        callback(new Error('Another installPatch operation is already pending.'));
      }
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (EVENT_TYPES.includes(name)) {
        this._nativeListen(name, listening);
      } else {
        _get(App.prototype.__proto__ || Object.getPrototypeOf(App.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name) {
      var event = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (name === 'patchInstall') {
        this._nativeListen('patchInstall', false);
        var callback = this._pendingPatchCallback;
        delete this._pendingPatchCallback;
        if (typeof callback === 'function') {
          if (event.error) {
            callback(new Error(event.error));
          } else {
            try {
              var patch = event.success ? JSON.parse(event.success) : null;
              callback(null, patch);
            } catch (error) {
              callback(new Error('Failed to parse patch.json'));
            }
          }
        }
      } else {
        return _get(App.prototype.__proto__ || Object.getPrototypeOf(App.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '_validateCertificate',
    value: function _validateCertificate(event) {
      var hashes = this.$pinnedCerts[event.host];
      if (hashes && !hashes.some(function (hash) {
        return event.hashes.includes(hash);
      })) {
        event.preventDefault();
      }
    }
  }, {
    key: 'id',
    get: function () {
      return this._nativeGet('appId');
    }
  }, {
    key: 'version',
    get: function () {
      return this._nativeGet('version');
    }
  }, {
    key: 'versionCode',
    get: function () {
      return this._nativeGet('versionId');
    }
  }]);

  return App;
}(NativeObject);

NativeObject.defineProperties(App.prototype, {
  pinnedCertificates: {
    type: 'array',
    default: function () {
      return [];
    },
    set: function (name, value) {
      this.$pinnedCerts = checkCertificates(value);
      this.on('certificatesReceived', this._validateCertificate, this);
      this._storeProperty(name, value);
      this._nativeSet(name, value);
    }
  }
});

function checkCertificates(certificates) {
  var hashes = {};
  for (var cert of certificates) {
    if (typeof cert.host !== 'string') {
      throw new Error('Invalid host for pinned certificate: ' + cert.host);
    }
    if (typeof cert.hash !== 'string' || !cert.hash.startsWith('sha256/')) {
      throw new Error('Invalid hash for pinned certificate: ' + cert.hash);
    }
    if (tabris.device.platform === 'iOS') {
      if (!('algorithm' in cert)) {
        throw new Error('Missing algorithm for pinned certificate: ' + cert.host);
      }
      if (typeof cert.algorithm !== 'string' || CERTIFICATE_ALGORITHMS.indexOf(cert.algorithm) === -1) {
        throw new Error('Invalid algorithm for pinned certificate: ' + cert.algorithm);
      }
    }
    hashes[cert.host] = hashes[cert.host] || [];
    hashes[cert.host].push(cert.hash);
  }
  return hashes;
}

function create$2() {
  return new App(true);
}

function normalizePath$1(path) {
  return path.split(/\/+/).map(function (segment) {
    if (segment === '..') {
      throw new Error("Path must not contain '..'");
    }
    if (segment === '.') {
      return '';
    }
    return segment;
  }).filter(function (string) {
    return !!string;
  }).join('/');
}

var GestureRecognizer = function (_NativeObject4) {
  _inherits(GestureRecognizer, _NativeObject4);

  function GestureRecognizer(properties) {
    _classCallCheck(this, GestureRecognizer);

    var _this11 = _possibleConstructorReturn(this, (GestureRecognizer.__proto__ || Object.getPrototypeOf(GestureRecognizer)).call(this));

    _this11._create('tabris.GestureRecognizer', properties);
    return _this11;
  }

  _createClass(GestureRecognizer, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'gesture') {
        this._nativeListen(name, listening);
      } else {
        _get(GestureRecognizer.prototype.__proto__ || Object.getPrototypeOf(GestureRecognizer.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }]);

  return GestureRecognizer;
}(NativeObject);

NativeObject.defineProperties(GestureRecognizer.prototype, {
  type: 'string',
  target: 'proxy',
  fingers: 'natural',
  touches: 'natural',
  duration: 'natural',
  direction: 'string'
});

var ANIMATABLE_PROPERTIES = ['opacity', 'transform'];

var PROPERTIES = {
  properties: { type: 'any' },
  delay: { type: 'natural' },
  duration: { type: 'natural' },
  repeat: { type: 'natural' },
  reverse: { type: 'boolean' },
  easing: { type: ['choice', ['linear', 'ease-in', 'ease-out', 'ease-in-out']] },
  target: { type: 'proxy' }
};

var Animation = function (_NativeObject5) {
  _inherits(Animation, _NativeObject5);

  function Animation(properties) {
    _classCallCheck(this, Animation);

    var _this12 = _possibleConstructorReturn(this, (Animation.__proto__ || Object.getPrototypeOf(Animation)).call(this));

    _this12._create('tabris.Animation', properties);
    _this12._nativeListen('completed', true);
    return _this12;
  }

  _createClass(Animation, [{
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'completed') {
        this.target.off('dispose', this.abort, this);
        if (this._resolve) {
          this._resolve();
        }
        this.dispose();
      } else {
        _get(Animation.prototype.__proto__ || Object.getPrototypeOf(Animation.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: 'start',
    value: function start(resolve, reject) {
      this.target.on('dispose', this.abort, this);
      this._resolve = resolve;
      this._reject = reject;
      this._nativeCall('start');
    }
  }, {
    key: 'abort',
    value: function abort() {
      if (this._reject) {
        this._reject();
      }
      this.dispose();
    }
  }]);

  return Animation;
}(NativeObject);

NativeObject.defineProperties(Animation.prototype, PROPERTIES);

function animate(properties, options) {
  var _this13 = this;

  var animatedProps = {};
  for (var property in properties) {
    if (ANIMATABLE_PROPERTIES.includes(property)) {
      try {
        animatedProps[property] = this._encodeProperty(this._getTypeDef(property), properties[property]);
        this._storeProperty(property, animatedProps[property], options);
      } catch (ex) {
        warn(this + ': Ignored invalid animation property value for "' + property + '"');
      }
    } else {
      warn(this + ': Ignored invalid animation property "' + property + '"');
    }
  }
  for (var option in options) {
    if (!(option in PROPERTIES) && option !== 'name') {
      warn(this + ': Ignored invalid animation option "' + option + '"');
    }
  }
  return new Promise(function (resolve, reject) {
    new Animation(Object.assign({}, options, {
      target: _this13,
      properties: animatedProps
    })).start(resolve, reject);
  });
}

var EVENT_TYPES$1 = ['touchStart', 'touchMove', 'touchEnd', 'touchCancel', 'resize'];

var Widget = function (_NativeObject6) {
  _inherits(Widget, _NativeObject6);

  function Widget(properties) {
    _classCallCheck(this, Widget);

    var _this14 = _possibleConstructorReturn(this, (Widget.__proto__ || Object.getPrototypeOf(Widget)).call(this));

    if (_this14.constructor === Widget) {
      throw new Error('Cannot instantiate abstract Widget');
    }
    if (_this14._nativeType) {
      _this14._create(_this14._nativeType, properties);
    }
    return _this14;
  }

  _createClass(Widget, [{
    key: 'append',
    value: function append() {
      var _this15 = this;

      this._checkDisposed();
      var accept = function (widget) {
        if (!(widget instanceof NativeObject)) {
          throw new Error('Cannot append non-widget');
        }
        widget._setParent(_this15);
      };
      if (arguments[0] instanceof WidgetCollection) {
        arguments[0].toArray().forEach(accept);
      } else if (Array.isArray(arguments[0])) {
        arguments[0].forEach(accept);
      } else {
        Array.prototype.forEach.call(arguments, accept);
      }
      return this;
    }
  }, {
    key: 'appendTo',
    value: function appendTo(widget) {
      this._checkDisposed();
      widget = widget instanceof WidgetCollection ? widget.first() : widget;
      if (!(widget instanceof NativeObject)) {
        throw new Error('Cannot append to non-widget');
      }
      this._setParent(widget);
      return this;
    }
  }, {
    key: 'insertBefore',
    value: function insertBefore(widget) {
      this._checkDisposed();
      widget = widget instanceof WidgetCollection ? widget.first() : widget;
      if (!(widget instanceof NativeObject)) {
        throw new Error('Cannot insert before non-widget');
      }
      var parent = widget.parent();
      if (!parent) {
        throw new Error('Cannot insert before orphan');
      }
      var index = parent.$children.indexOf(widget);
      this._setParent(parent, index);
      return this;
    }
  }, {
    key: 'insertAfter',
    value: function insertAfter(widget) {
      this._checkDisposed();
      widget = widget instanceof WidgetCollection ? widget.first() : widget;
      if (!(widget instanceof NativeObject)) {
        throw new Error('Cannot insert after non-widget');
      }
      var parent = widget.parent();
      if (!parent) {
        throw new Error('Cannot insert after orphan');
      }
      var index = parent.$children.indexOf(widget);
      this._setParent(parent, index + 1);
      return this;
    }
  }, {
    key: 'detach',
    value: function detach() {
      this._checkDisposed();
      this._setParent(null);
      return this;
    }
  }, {
    key: 'parent',
    value: function parent() {
      return this._parent || null;
    }
  }, {
    key: 'children',
    value: function children(selector) {
      return this._children(selector);
    }
  }, {
    key: 'siblings',
    value: function siblings(selector) {
      var _this16 = this;

      var siblings = this._parent ? this._parent._children() : [];
      var filtered = siblings.filter(function (widget) {
        return widget !== _this16;
      });
      return new WidgetCollection(filtered, selector);
    }
  }, {
    key: 'find',
    value: function find(selector) {
      return new WidgetCollection(this.children(), selector, true);
    }
  }, {
    key: 'apply',
    value: function apply(sheet) {
      var scope = new WidgetCollection(asArray(this.children()).concat(this), '*', true);
      return this._apply(sheet, scope);
    }
  }, {
    key: '_getContainer',
    value: function _getContainer() {
      return this;
    }
  }, {
    key: '_children',
    value: function _children(selector) {
      return new WidgetCollection(this.$children, selector);
    }
  }, {
    key: '_find',
    value: function _find(selector) {
      return new WidgetCollection(this._children(), selector, true);
    }
  }, {
    key: '_apply',
    value: function _apply(sheet, scope) {
      if (arguments.length === 1) {
        scope = new WidgetCollection(asArray(this._children()).concat(this), '*', true);
      }
      if (sheet['*']) {
        scope.set(sheet['*']);
      }
      for (var selector in sheet) {
        if (selector !== '*' && selector[0] !== '#' && selector[0] !== '.') {
          scope.filter(selector).set(sheet[selector]);
        }
      }
      for (var _selector in sheet) {
        if (_selector[0] === '.') {
          scope.filter(_selector).set(sheet[_selector]);
        }
      }
      for (var _selector2 in sheet) {
        if (_selector2[0] === '#') {
          scope.filter(_selector2).set(sheet[_selector2]);
        }
      }
      return this;
    }
  }, {
    key: '_setParent',
    value: function _setParent(parent, index) {
      this._nativeSet('parent', parent ? types.proxy.encode(parent._getContainer(this)) : null);
      if (this._parent) {
        this._parent._removeChild(this);
        Layout.addToQueue(this._parent);
      }
      this._parent = parent;
      if (this._parent) {
        this._parent._addChild(this, index);
        Layout.addToQueue(this._parent);
      }
    }
  }, {
    key: '_acceptChild',
    value: function _acceptChild() {
      return false;
    }
  }, {
    key: '_addChild',
    value: function _addChild(child, index) {
      if (!this._acceptChild(child)) {
        throw new Error(child + ' could not be appended to ' + this);
      }
      if (!this.$children) {
        this.$children = [];
      }
      if (typeof index === 'number') {
        this.$children.splice(index, 0, child);
      } else {
        index = this.$children.push(child) - 1;
      }
      _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_trigger', this).call(this, 'addChild', { child: child, index: index });
    }
  }, {
    key: '_removeChild',
    value: function _removeChild(child) {
      if (this.$children) {
        var index = this.$children.indexOf(child);
        if (index !== -1) {
          this.$children.splice(index, 1);
          _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_trigger', this).call(this, 'removeChild', { child: child, index: index });
        }
      }
    }
  }, {
    key: '_release',
    value: function _release() {
      if (this.$children) {
        var children = this.$children.concat();
        for (var i = 0; i < children.length; i++) {
          children[i]._dispose(true);
        }
        delete this.$children;
      }
      if (this._parent) {
        this._parent._removeChild(this);
        Layout.addToQueue(this._parent);
        delete this._parent;
      }
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      var _this17 = this;

      if (this._isDisposed) {
        return;
      }
      if (this.gestures[name]) {
        if (listening) {
          var properties = Object.assign({ target: this }, this.gestures[name]);
          var recognizer = new GestureRecognizer(properties).on('gesture', function (event) {
            if (event.translation) {
              event.translationX = event.translation.x;
              event.translationY = event.translation.y;
            }
            if (event.velocity) {
              event.velocityX = event.velocity.x;
              event.velocityY = event.velocity.y;
            }
            _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_trigger', _this17).call(_this17, name, event);
          });
          if (!this._recognizers) {
            this._recognizers = {};
          }
          this._recognizers[name] = recognizer;
          this.on('dispose', recognizer.dispose, recognizer);
        } else if (this._recognizers && name in this._recognizers) {
          this._recognizers[name].dispose();
          delete this._recognizers[name];
        }
      } else if (name === 'boundsChanged') {
        this._onoff('resize', listening, this.$triggerChangeBounds);
      } else if (EVENT_TYPES$1.includes(name)) {
        this._nativeListen(name, listening);
      } else {
        _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      var _this18 = this;

      if (name === 'resize') {
        if (hasAndroidResizeBug()) {
          setTimeout(function () {
            return _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_trigger', _this18).call(_this18, name, types.bounds.decode(event.bounds));
          }, 0);
        } else {
          _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_trigger', this).call(this, name, types.bounds.decode(event.bounds));
        }
      } else {
        return _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '$triggerChangeBounds',
    value: function $triggerChangeBounds(_ref) {
      var { left: left, top: top, width: width, height: height } = _ref;

      _get(Widget.prototype.__proto__ || Object.getPrototypeOf(Widget.prototype), '_trigger', this).call(this, 'boundsChanged', { value: { left: left, top: top, width: width, height: height } });
    }
  }, {
    key: '_flushLayout',
    value: function _flushLayout() {
      if (this.$children) {
        this.$children.forEach(function (child) {
          renderLayoutData.call(child);
        });
      }
    }
  }, {
    key: 'data',
    get: function () {
      if (!this.$data) {
        this.$data = {};
      }
      return this.$data;
    }
  }, {
    key: 'classList',
    get: function () {
      if (!this._classList) {
        this._classList = [];
      }
      return this._classList;
    }
  }]);

  return Widget;
}(NativeObject);

NativeObject.defineProperties(Widget.prototype, {
  enabled: {
    type: 'boolean',
    default: true
  },
  visible: {
    type: 'boolean',
    default: true
  },
  layoutData: {
    type: 'layoutData',
    set: function (name, value) {
      this._layoutData = value;
      if (this._parent) {
        Layout.addToQueue(this._parent);
      }
    },
    get: function () {
      return this._layoutData || null;
    }
  },
  left: { type: 'edge', get: getLayoutProperty, set: setLayoutProperty },
  right: { type: 'edge', get: getLayoutProperty, set: setLayoutProperty },
  top: { type: 'edge', get: getLayoutProperty, set: setLayoutProperty },
  bottom: { type: 'edge', get: getLayoutProperty, set: setLayoutProperty },
  width: { type: 'dimension', get: getLayoutProperty, set: setLayoutProperty },
  height: { type: 'dimension', get: getLayoutProperty, set: setLayoutProperty },
  centerX: { type: 'dimension', get: getLayoutProperty, set: setLayoutProperty },
  centerY: { type: 'dimension', get: getLayoutProperty, set: setLayoutProperty },
  baseline: { type: 'sibling', get: getLayoutProperty, set: setLayoutProperty },
  elevation: {
    type: 'number',
    default: 0
  },
  font: {
    type: 'font',
    set: function (name, value) {
      this._nativeSet(name, value === undefined ? null : value);
      this._storeProperty(name, value);
    },

    default: null
  },
  backgroundImage: {
    type: 'image'
  },
  bounds: {
    type: 'bounds',
    readonly: true
  },
  background: {
    type: 'color',
    set: function (name, value) {
      this._nativeSet(name, value === undefined ? null : value);
      this._storeProperty(name, value);
    }
  },
  opacity: {
    type: 'opacity',
    default: 1
  },
  transform: {
    type: 'transform',
    default: function () {
      return {
        rotation: 0,
        scaleX: 1,
        scaleY: 1,
        translationX: 0,
        translationY: 0,
        translationZ: 0
      };
    }
  },
  highlightOnTouch: {
    type: 'boolean',
    default: false
  },
  cornerRadius: {
    type: 'number',
    default: 0
  },
  id: {
    type: 'string',
    set: function (name, value) {
      this._storeProperty(name, value);
    },
    get: function (name) {
      return this._getStoredProperty(name);
    }
  },
  class: {
    type: 'string',
    set: function (name, value) {
      this._classList = value.trim().split(/\s+/);
    },
    get: function () {
      return this.classList.join(' ');
    }
  },
  gestures: {
    set: function (name, gestures) {
      this._gestures = Object.assign({}, defaultGestures, gestures);
    },
    get: function () {
      if (!this._gestures) {
        this._gestures = Object.assign({}, defaultGestures);
      }
      return this._gestures;
    }
  },
  win_theme: {
    type: ['choice', ['default', 'light', 'dark']],
    default: 'default'
  }
});

Widget.prototype.animate = animate;

function hasAndroidResizeBug() {
  if (!('cache' in hasAndroidResizeBug)) {
    hasAndroidResizeBug.cache = tabris.device.platform === 'Android' && tabris.device.version <= 17;
  }
  return hasAndroidResizeBug.cache;
}

var defaultGestures = {
  tap: { type: 'tap' },
  longpress: { type: 'longpress' },
  pan: { type: 'pan' },
  panLeft: { type: 'pan', direction: 'left' },
  panRight: { type: 'pan', direction: 'right' },
  panUp: { type: 'pan', direction: 'up' },
  panDown: { type: 'pan', direction: 'down' },
  panHorizontal: { type: 'pan', direction: 'horizontal' },
  panVertical: { type: 'pan', direction: 'vertical' },
  swipeLeft: { type: 'swipe', direction: 'left' },
  swipeRight: { type: 'swipe', direction: 'right' },
  swipeUp: { type: 'swipe', direction: 'up' },
  swipeDown: { type: 'swipe', direction: 'down' }
};

function renderLayoutData() {
  if (this._layoutData) {
    var checkedData = Layout.checkConsistency(this._layoutData);
    this._nativeSet('layoutData', Layout.resolveReferences(checkedData, this));
  }
}

function setLayoutProperty(name, value) {
  if (!this._layoutData) {
    this._layoutData = {};
  }
  if (value == null) {
    delete this._layoutData[name];
  } else {
    this._layoutData[name] = value;
  }
  if (this._parent) {
    Layout.addToQueue(this._parent);
  }
}

function getLayoutProperty(name) {
  return this._layoutData && this._layoutData[name] != null ? this._layoutData[name] : null;
}

function asArray(value) {
  if (!value) {
    return [];
  }
  if (value instanceof WidgetCollection) {
    return value.toArray();
  }
  return value;
}

var Composite = function (_Widget) {
  _inherits(Composite, _Widget);

  function Composite() {
    _classCallCheck(this, Composite);

    return _possibleConstructorReturn(this, (Composite.__proto__ || Object.getPrototypeOf(Composite)).apply(this, arguments));
  }

  _createClass(Composite, [{
    key: '_acceptChild',
    value: function _acceptChild() {
      return true;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Composite';
    }
  }]);

  return Composite;
}(Widget);

NativeObject.defineProperties(Composite.prototype, {
  padding: {
    type: 'boxDimensions',
    default: { left: 0, right: 0, top: 0, bottom: 0 }
  }
});

var ContentView = function (_Composite) {
  _inherits(ContentView, _Composite);

  function ContentView() {
    _classCallCheck(this, ContentView);

    if (arguments[0] !== true) {
      throw new Error('ContentView can not be created');
    }
    return _possibleConstructorReturn(this, (ContentView.__proto__ || Object.getPrototypeOf(ContentView)).call(this));
  }

  _createClass(ContentView, [{
    key: '_create',
    value: function _create(type, properties) {
      _get(ContentView.prototype.__proto__ || Object.getPrototypeOf(ContentView.prototype), '_create', this).call(this, type, properties);
      this._nativeSet('root', true);
    }
  }, {
    key: '_setParent',
    value: function _setParent(parent, index) {
      if (this._parent) {
        throw new Error('Parent of ContentView can not be changed');
      }
      _get(ContentView.prototype.__proto__ || Object.getPrototypeOf(ContentView.prototype), '_setParent', this).call(this, parent, index);
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      throw new Error('ContentView can not be disposed');
    }
  }]);

  return ContentView;
}(Composite);

function create$4() {
  return new ContentView(true);
}

var StatusBar = function (_Widget2) {
  _inherits(StatusBar, _Widget2);

  function StatusBar() {
    _classCallCheck(this, StatusBar);

    if (arguments[0] !== true) {
      throw new Error('StatusBar can not be created');
    }
    return _possibleConstructorReturn(this, (StatusBar.__proto__ || Object.getPrototypeOf(StatusBar)).call(this));
  }

  _createClass(StatusBar, [{
    key: '_setParent',
    value: function _setParent(parent, index) {
      if (this._parent) {
        throw new Error('Parent of StatusBar can not be changed');
      }
      _get(StatusBar.prototype.__proto__ || Object.getPrototypeOf(StatusBar.prototype), '_setParent', this).call(this, parent, index);
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      throw new Error('StatusBar can not be disposed');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.StatusBar';
    }
  }]);

  return StatusBar;
}(Widget);

NativeObject.defineProperties(StatusBar.prototype, {
  theme: { type: ['choice', ['default', 'light', 'dark']], default: 'default' },
  displayMode: { type: ['choice', ['default', 'float', 'hide']], default: 'default' },
  height: {
    type: 'number',
    readonly: true
  },
  background: { type: 'color', nocache: true }
});

function create$5() {
  return new StatusBar(true);
}

var NavigationBar = function (_Widget3) {
  _inherits(NavigationBar, _Widget3);

  function NavigationBar() {
    _classCallCheck(this, NavigationBar);

    if (arguments[0] !== true) {
      throw new Error('NavigationBar can not be created');
    }
    return _possibleConstructorReturn(this, (NavigationBar.__proto__ || Object.getPrototypeOf(NavigationBar)).call(this));
  }

  _createClass(NavigationBar, [{
    key: '_setParent',
    value: function _setParent(parent, index) {
      if (this._parent) {
        throw new Error('Parent of NavigationBar can not be changed');
      }
      _get(NavigationBar.prototype.__proto__ || Object.getPrototypeOf(NavigationBar.prototype), '_setParent', this).call(this, parent, index);
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      throw new Error('NavigationBar can not be disposed');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.NavigationBar';
    }
  }]);

  return NavigationBar;
}(Widget);

NativeObject.defineProperties(NavigationBar.prototype, {
  theme: { type: ['choice', ['default', 'light', 'dark']], default: 'default' },
  displayMode: { type: ['choice', ['default', 'float', 'hide']], default: 'default' },
  height: {
    type: 'number',
    readonly: true
  },
  background: { type: 'color', nocache: true }
});

function create$6() {
  return new NavigationBar(true);
}

var Drawer = function (_Composite2) {
  _inherits(Drawer, _Composite2);

  function Drawer() {
    _classCallCheck(this, Drawer);

    if (arguments[0] !== true) {
      throw new Error('Drawer can not be created');
    }
    return _possibleConstructorReturn(this, (Drawer.__proto__ || Object.getPrototypeOf(Drawer)).call(this));
  }

  _createClass(Drawer, [{
    key: '_setParent',
    value: function _setParent(parent, index) {
      if (this._parent) {
        throw new Error('Parent of Drawer can not be changed');
      }
      _get(Drawer.prototype.__proto__ || Object.getPrototypeOf(Drawer.prototype), '_setParent', this).call(this, parent, index);
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'open' || name === 'close') {
        this._nativeListen(name, listening);
      } else {
        _get(Drawer.prototype.__proto__ || Object.getPrototypeOf(Drawer.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      throw new Error('Drawer can not be disposed');
    }
  }, {
    key: 'open',
    value: function open() {
      this._nativeCall('open', {});
      return this;
    }
  }, {
    key: 'close',
    value: function close() {
      this._nativeCall('close', {});
      return this;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Drawer';
    }
  }]);

  return Drawer;
}(Composite);

NativeObject.defineProperties(Drawer.prototype, {
  enabled: {
    type: 'boolean',
    default: false
  },
  win_targetView: {
    type: 'proxy'
  },
  win_displayMode: {
    type: ['choice', ['overlay', 'compactOverlay', 'inline', 'compactInline']],
    default: 'overlay'
  }
});

function create$7() {
  return new Drawer(true);
}

var Ui = function (_Composite3) {
  _inherits(Ui, _Composite3);

  function Ui() {
    _classCallCheck(this, Ui);

    if (arguments[0] !== true) {
      throw new Error('Ui can not be created');
    }

    var _this24 = _possibleConstructorReturn(this, (Ui.__proto__ || Object.getPrototypeOf(Ui)).call(this));

    _this24.$appendNamedChild('contentView', create$4());
    _this24.$appendNamedChild('statusBar', create$5());
    _this24.$appendNamedChild('navigationBar', create$6());
    _this24.$appendNamedChild('drawer', create$7());
    return _this24;
  }

  _createClass(Ui, [{
    key: '_acceptChild',
    value: function _acceptChild(child) {
      return child === this.contentView || child === this.statusBar || child === this.navigationBar || child === this.drawer;
    }
  }, {
    key: '$appendNamedChild',
    value: function $appendNamedChild(name, child) {
      Object.defineProperty(this, name, { value: child });
      this.append(child);
    }
  }, {
    key: '_setParent',
    value: function _setParent() {
      throw new Error('Parent of tabris.ui can not be changed');
    }
  }, {
    key: '_dispose',
    value: function _dispose() {
      throw new Error('Ui can not be disposed');
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Ui';
    }
  }]);

  return Ui;
}(Composite);

function create$3() {
  return new Ui(true);
}

NativeObject.defineProperties(Ui.prototype, {
  win_theme: {
    type: ['choice', ['default', 'light', 'dark']],
    default: 'light'
  }
});

var SUPPORTED_ENCODINGS = ['ascii', 'utf-8'];

var TextEncoder = function (_NativeObject7) {
  _inherits(TextEncoder, _NativeObject7);

  function TextEncoder() {
    _classCallCheck(this, TextEncoder);

    var _this25 = _possibleConstructorReturn(this, (TextEncoder.__proto__ || Object.getPrototypeOf(TextEncoder)).call(this));

    _this25._create('tabris.TextEncoder');
    _this25._nativeListen('result', true);
    _this25._nativeListen('error', true);
    return _this25;
  }

  _createClass(TextEncoder, [{
    key: 'encode',
    value: function encode(text, encoding) {
      this._nativeCall('encode', { text: text, encoding: encoding });
    }
  }], [{
    key: 'encode',
    value: function encode(text, encoding) {
      return new Promise(function (resolve, reject) {
        if (typeof text !== 'string') {
          throw new Error('Invalid text, must be a string');
        }
        encoding = encoding || 'utf-8';
        if (!SUPPORTED_ENCODINGS.includes(encoding)) {
          throw new Error('Unsupported encoding: \'' + encoding + '\'');
        }
        new TextEncoder().on('result', function (_ref2) {
          var { target: target, data: data } = _ref2;

          resolve(data);
          target.dispose();
        }).on('error', function (_ref3) {
          var { target: target } = _ref3;

          reject(new Error('Could not encode ' + encoding));
          target.dispose();
        }).encode(text, encoding);
      });
    }
  }]);

  return TextEncoder;
}(NativeObject);

var SUPPORTED_ENCODINGS$1 = ['ascii', 'utf-8'];

var TextDecoder = function (_NativeObject8) {
  _inherits(TextDecoder, _NativeObject8);

  function TextDecoder() {
    _classCallCheck(this, TextDecoder);

    var _this26 = _possibleConstructorReturn(this, (TextDecoder.__proto__ || Object.getPrototypeOf(TextDecoder)).call(this));

    _this26._create('tabris.TextDecoder');
    _this26._nativeListen('result', true);
    _this26._nativeListen('error', true);
    return _this26;
  }

  _createClass(TextDecoder, [{
    key: 'decode',
    value: function decode(buffer, encoding) {
      this._nativeCall('decode', { data: buffer, encoding: encoding });
    }
  }], [{
    key: 'decode',
    value: function decode(buffer, encoding) {
      return new Promise(function (resolve, reject) {
        if (ArrayBuffer.isView(buffer)) {
          buffer = buffer.buffer;
        }
        if (!(buffer instanceof ArrayBuffer)) {
          throw new Error('Invalid buffer type');
        }
        encoding = encoding || 'utf-8';
        if (!SUPPORTED_ENCODINGS$1.includes(encoding)) {
          throw new Error('Unsupported encoding: \'' + encoding + '\'');
        }
        new TextDecoder().on('result', function (_ref4) {
          var { target: target, string: string } = _ref4;

          resolve(string);
          target.dispose();
        }).on('error', function (_ref5) {
          var { target: target } = _ref5;

          reject(new Error('Could not decode ' + encoding));
          target.dispose();
        }).decode(buffer, encoding);
      });
    }
  }]);

  return TextDecoder;
}(NativeObject);

var ERRORS = {
  EACCES: 'Permission denied',
  EEXIST: 'File exists',
  ENOENT: 'No such file or directory',
  EISDIR: 'Is a directory',
  ENOTDIR: 'Not a directory',
  ENOTEMPTY: 'Directory not empty'
};

var FileSystem = function (_NativeObject9) {
  _inherits(FileSystem, _NativeObject9);

  function FileSystem() {
    _classCallCheck(this, FileSystem);

    var _this27 = _possibleConstructorReturn(this, (FileSystem.__proto__ || Object.getPrototypeOf(FileSystem)).call(this, 'tabris.FileSystem'));

    if (arguments[0] !== true) {
      throw new Error('FileSystem can not be created');
    }
    _this27._create('tabris.FileSystem');
    return _this27;
  }

  _createClass(FileSystem, [{
    key: 'readFile',
    value: function readFile(path, encoding) {
      var _arguments10 = arguments,
          _this28 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments10.length < 1) {
          throw new Error('Not enough arguments to readFile');
        }
        _this28._nativeCall('readFile', {
          path: checkPath(path),
          onError: function (err) {
            return reject(createError(err, path));
          },
          onSuccess: function (data) {
            return encoding ? TextDecoder.decode(data, encoding).then(resolve, reject) : resolve(data);
          }
        });
      });
    }
  }, {
    key: 'writeFile',
    value: function writeFile(path, data, encoding) {
      var _arguments11 = arguments,
          _this29 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments11.length < 2) {
          throw new Error('Not enough arguments to writeFile');
        }
        var write = function (data) {
          return _this29._nativeCall('writeFile', {
            path: checkPath(path),
            data: checkBuffer(data),
            onError: function (err) {
              return reject(createError(err, path));
            },
            onSuccess: function () {
              return resolve();
            }
          });
        };
        if (typeof data === 'string') {
          TextEncoder.encode(data, encoding || 'utf-8').then(write, reject);
        } else {
          write(data);
        }
      });
    }
  }, {
    key: 'removeFile',
    value: function removeFile(path) {
      var _arguments12 = arguments,
          _this30 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments12.length < 1) {
          throw new Error('Not enough arguments to removeFile');
        }
        _this30._nativeCall('removeFile', {
          path: checkPath(path),
          onError: function (err) {
            return reject(createError(err, path));
          },
          onSuccess: function () {
            return resolve();
          }
        });
      });
    }
  }, {
    key: 'readDir',
    value: function readDir(path) {
      var _arguments13 = arguments,
          _this31 = this;

      return new Promise(function (resolve, reject) {
        if (_arguments13.length < 1) {
          throw new Error('Not enough arguments to readDir');
        }
        _this31._nativeCall('readDir', {
          path: checkPath(path),
          onError: function (err) {
            return reject(createError(err, path));
          },
          onSuccess: function (data) {
            return resolve(data);
          }
        });
      });
    }
  }, {
    key: 'dispose',
    value: function dispose() {
      throw new Error('Cannot dispose fs object');
    }
  }, {
    key: 'filesDir',
    get: function () {
      return this._nativeGet('filesDir');
    }
  }, {
    key: 'cacheDir',
    get: function () {
      return this._nativeGet('cacheDir');
    }
  }]);

  return FileSystem;
}(NativeObject);

function create$8() {
  return new FileSystem(true);
}

function createError(err, path) {
  var message = (ERRORS[err] || err) + ': ' + path;
  var code = err in ERRORS ? err : null;
  var error = new Error(message);
  Object.defineProperties(error, {
    path: { value: path },
    code: { value: code }
  });
  return error;
}

function checkPath(path) {
  try {
    return normalizePath(path);
  } catch (err) {
    throw new Error('Invalid file name: ' + err.message);
  }
}

function checkBuffer(buffer) {
  if (ArrayBuffer.isView(buffer)) {
    buffer = buffer.buffer;
  }
  if (!(buffer instanceof ArrayBuffer)) {
    throw new Error('Invalid buffer type');
  }
  return buffer;
}

var PHASE_CONSTANTS = {
  NONE: { value: 0 },
  CAPTURING_PHASE: { value: 1 },
  AT_TARGET: { value: 2 },
  BUBBLING_PHASE: { value: 3 }
};

var Event = function () {
  function Event(type, config) {
    _classCallCheck(this, Event);

    if (arguments.length < 1) {
      throw new Error('Not enough arguments to Event');
    }
    this.$timeStamp = Date.now();
    this.$type = type || '';
    this.$bubbles = config && !!config.bubbles || false;
    this.$cancelable = config && !!config.cancelable || false;
    this.$target = null;
    this.$defaultPrevented = false;
  }

  _createClass(Event, [{
    key: 'initEvent',
    value: function initEvent(type, bubbles, cancelable) {
      if (arguments.length < 3) {
        throw new Error('Not enough arguments to initEvent');
      }
      this.$type = type + '';
      this.$bubbles = !!bubbles;
      this.$cancelable = !!cancelable;
    }
  }, {
    key: 'stopPropagation',
    value: function stopPropagation() {}
  }, {
    key: 'stopImmediatePropagation',
    value: function stopImmediatePropagation() {}
  }, {
    key: 'preventDefault',
    value: function preventDefault() {
      if (this.$cancelable) {
        this.$defaultPrevented = true;
      }
    }
  }, {
    key: 'type',
    get: function () {
      return this.$type;
    }
  }, {
    key: 'timeStamp',
    get: function () {
      return this.$timeStamp;
    }
  }, {
    key: 'bubbles',
    get: function () {
      return this.$bubbles;
    }
  }, {
    key: 'cancelable',
    get: function () {
      return this.$cancelable;
    }
  }, {
    key: 'target',
    get: function () {
      return this.$target;
    }
  }, {
    key: 'currentTarget',
    get: function () {
      return this.$target;
    }
  }, {
    key: 'defaultPrevented',
    get: function () {
      return this.$defaultPrevented;
    }
  }, {
    key: 'eventPhase',
    get: function () {
      return 0;
    }
  }, {
    key: 'isTrusted',
    get: function () {
      return false;
    }
  }]);

  return Event;
}();

Object.defineProperties(Event, PHASE_CONSTANTS);
Object.defineProperties(Event.prototype, PHASE_CONSTANTS);

function addDOMEventTargetMethods(target) {

  if (typeof target.addEventListener === 'function') {
    return;
  }

  var listeners = void 0;

  target.addEventListener = function (type, listener /*, useCapture*/) {
    if (arguments.length < 2) {
      throw new Error('Not enough arguments to addEventListener');
    }
    if (!listeners) {
      listeners = [];
    }
    if (!(type in listeners)) {
      listeners[type] = [];
    }
    if (!listeners[type].includes(listener)) {
      listeners[type].push(listener);
    }
  };

  target.removeEventListener = function (type, listener /*, useCapture*/) {
    if (arguments.length < 2) {
      throw new Error('Not enough arguments to removeEventListener');
    }
    if (listeners && type in listeners) {
      var index = listeners[type].indexOf(listener);
      if (index !== -1) {
        listeners[type].splice(index, 1);
      }
    }
  };

  target.dispatchEvent = function (event) {
    if (arguments.length < 1) {
      throw new Error('Not enough arguments to dispatchEvent');
    }
    if (!(event instanceof Event)) {
      throw new Error('Invalid event given to dispatchEvent');
    }
    event.$target = target;
    if (listeners && event.type in listeners) {
      for (var listener of listeners[event.type]) {
        listener.call(this, event);
      }
    }
    return !event.defaultPrevented;
  };
}

function defineEventHandlerProperties(target, types) {
  types.forEach(function (type) {
    return defineEventHandlerProperty(target, type);
  });
}

function defineEventHandlerProperty(target, type) {
  var handler = 'on' + type;
  var listener = null;
  Object.defineProperty(target, handler, {
    get: function () {
      return listener;
    },
    set: function (value) {
      // ignore other types, mimicks the behavior of Firefox and Chromium
      if (typeof value === 'function') {
        if (listener) {
          target.removeEventListener(type, listener);
        }
        listener = value;
        target.addEventListener(type, listener);
      }
    }
  });
}

function addDOMDocument(target) {
  var HTMLElement = function () {
    function HTMLElement(tagName) {
      _classCallCheck(this, HTMLElement);

      this.tagName = (tagName || '').toUpperCase();
      this.children = [];
    }

    _createClass(HTMLElement, [{
      key: 'setAttribute',
      value: function setAttribute() {}
    }, {
      key: 'appendChild',
      value: function appendChild(el) {
        this.children.push(el);
        handleElementInserted(this, el, target);
        return el;
      }
    }, {
      key: 'cloneNode',
      value: function cloneNode() {
        return new HTMLElement();
      }
    }, {
      key: 'lastChild',
      value: function lastChild() {
        return new HTMLElement();
      }
    }]);

    return HTMLElement;
  }();

  target.document = {
    documentElement: {},
    createDocumentFragment: function () {
      return new HTMLElement();
    },
    createElement: function (tagName) {
      return new HTMLElement(tagName);
    },

    location: { href: '' },
    readyState: 'loading',
    head: new HTMLElement('head'),
    getElementsByTagName: function (tagName) {
      return this.head.children.filter(function (node) {
        return node.tagName === tagName.toUpperCase();
      });
    },
    createEvent: function (type) {
      return new Event(type);
    }
  };

  addDOMEventTargetMethods(target.document);
  if (typeof target.location === 'undefined') {
    target.location = target.document.location;
  }

  tabris.once('start', function () {
    target.document.readyState = 'complete';
    var event = new Event('DOMContentLoaded', false, false);
    target.document.dispatchEvent(event);
  });
}

function handleElementInserted(parent, child, target) {
  if (parent.tagName === 'HEAD' && child.tagName === 'SCRIPT' && child.src) {
    var result = void 0;
    try {
      result = tabris._client.loadAndExecute(child.src, '', '');
    } catch (ex) {
      error('Error loading ' + child.src + ':', ex);
      log(ex.stack);
      if (typeof child.onerror === 'function') {
        child.onerror.call(target, ex);
      }
      return;
    }
    if (result.loadError) {
      if (typeof child.onerror === 'function') {
        child.onerror.call(target, new Error('Could not load ' + child.src));
      }
    } else if (typeof child.onload === 'function') {
      child.onload.call(target);
    }
  }
}

var Timer = function (_NativeObject10) {
  _inherits(Timer, _NativeObject10);

  function Timer(properties) {
    _classCallCheck(this, Timer);

    var _this32 = _possibleConstructorReturn(this, (Timer.__proto__ || Object.getPrototypeOf(Timer)).call(this));

    _this32._create('tabris.Timer', properties);
    _this32._nativeListen('run', true);
    return _this32;
  }

  return Timer;
}(NativeObject);

NativeObject.defineProperties(Timer.prototype, { delay: 'any', repeat: 'any' });

function addWindowTimerMethods(target) {

  if (typeof target.setTimeout === 'function') {
    return;
  }

  var taskSequence = 0;
  var timers = {};

  function createTimer(fn, delay, repeat, args) {
    var taskId = taskSequence++;
    // If tabris is not ready, create the timer on load.
    // However, clearTimeout won't work until after load.
    var create = function () {
      var timer = new Timer({
        delay: delay,
        repeat: repeat
      }).on('run', function () {
        fn.apply(target, args);
        if (!repeat) {
          timer.dispose();
          delete timers[taskId];
        }
      });
      timer._nativeCall('start');
      timers[taskId] = timer;
    };
    if (tabris.started) {
      create();
    } else {
      tabris.once('start', create);
    }
    return taskId;
  }

  target.setTimeout = function (fn, delay) {
    if (arguments.length < 1) {
      throw new TypeError('Not enough arguments to setTimeout');
    }
    if (typeof fn !== 'function') {
      throw new TypeError('Illegal argument to setTimeout: not a function');
    }
    var args = Array.prototype.slice.call(arguments, 2);
    return createTimer(fn, adjustDelay(delay), false, args);
  };

  target.setInterval = function (fn, delay) {
    if (arguments.length < 1) {
      throw new TypeError('Not enough arguments to setInterval');
    }
    if (typeof fn !== 'function') {
      throw new TypeError('Illegal argument to setInterval: not a function');
    }
    var args = Array.prototype.slice.call(arguments, 2);
    return createTimer(fn, adjustDelay(delay), true, args);
  };

  target.clearTimeout = target.clearInterval = function (taskId) {
    var timer = timers[taskId];
    if (timer) {
      timer._nativeCall('cancel', {});
      timer.dispose();
      delete timers[taskId];
    }
  };
}

function adjustDelay(value) {
  return typeof value === 'number' && isFinite(value) ? Math.max(0, Math.round(value)) : 0;
}

var ClientStore = function (_NativeObject11) {
  _inherits(ClientStore, _NativeObject11);

  function ClientStore() {
    _classCallCheck(this, ClientStore);

    var _this33 = _possibleConstructorReturn(this, (ClientStore.__proto__ || Object.getPrototypeOf(ClientStore)).call(this));

    _this33._create('tabris.ClientStore');
    return _this33;
  }

  return ClientStore;
}(NativeObject);

var SecureStore = function (_NativeObject12) {
  _inherits(SecureStore, _NativeObject12);

  function SecureStore() {
    _classCallCheck(this, SecureStore);

    var _this34 = _possibleConstructorReturn(this, (SecureStore.__proto__ || Object.getPrototypeOf(SecureStore)).call(this));

    _this34._create('tabris.SecureStore');
    return _this34;
  }

  return SecureStore;
}(NativeObject);

var Storage = function () {
  function Storage() {
    _classCallCheck(this, Storage);

    var proxy = arguments[0];
    if (!(proxy instanceof NativeObject)) {
      throw new Error('Cannot instantiate Storage');
    }
    Object.defineProperty(this, '_proxy', { value: proxy });
  }

  // Note: key and length methods currently not supported

  _createClass(Storage, [{
    key: 'setItem',
    value: function setItem(key, value) {
      if (arguments.length < 2) {
        throw new TypeError("Not enough arguments to 'setItem'");
      }
      this._proxy._nativeCall('add', {
        key: encode(key),
        value: encode(value)
      });
    }
  }, {
    key: 'getItem',
    value: function getItem(key) {
      if (arguments.length < 1) {
        throw new TypeError("Not enough arguments to 'getItem'");
      }
      var result = this._proxy._nativeCall('get', { key: encode(key) });
      // Note: iOS can not return null, only undefined:
      return result === undefined ? null : result;
    }
  }, {
    key: 'removeItem',
    value: function removeItem(key) {
      if (arguments.length < 1) {
        throw new TypeError("Not enough arguments to 'removeItem'");
      }
      this._proxy._nativeCall('remove', { keys: [encode(key)] });
    }
  }, {
    key: 'clear',
    value: function clear() {
      this._proxy._nativeCall('clear');
    }
  }]);

  return Storage;
}();

function encode(value) {
  return '' + value;
}

function create$9(secure) {
  var proxy = secure ? new SecureStore() : new ClientStore();
  return new Storage(proxy);
}

function createElement(jsxType, attributes) {
  var Type = typeToConstructor(jsxType);

  for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }

  var appendable = flattenChildren(children).filter(function (child) {
    return child instanceof Widget;
  });
  if (Type === WidgetCollection) {
    if (attributes) {
      throw new Error('JSX: WidgetCollection can not have attributes');
    }
    return new WidgetCollection(appendable);
  }
  var result = new Type(getPropertiesMap(attributes || {}, children), children);
  if (result instanceof WidgetCollection) {
    return result;
  } else if (result instanceof Widget) {
    result.on(getListenersMap(attributes || {}));
    return result.append.apply(result, appendable);
  }
  throw new Error(('JSX: Unsupported type ' + Type.name).trim());
}

function typeToConstructor(jsxType) {
  if (jsxType instanceof Function) {
    return jsxType;
  }
  var typeName = jsxType.charAt(0).toUpperCase() + jsxType.slice(1);
  var Type = global.tabris[typeName];
  if (!(Type instanceof Function)) {
    throw new Error(('JSX: Unsupported type ' + jsxType).trim());
  }
  return Type;
}

function flattenChildren(children) {
  var result = [];
  for (var child of children) {
    if (child instanceof WidgetCollection) {
      result = result.concat(flattenChildren(child.toArray()));
    } else {
      result.push(child);
    }
  }
  return result;
}

function getPropertiesMap(attributes, children) {
  var properties = omit(attributes, Object.keys(attributes).filter(isEventAttribute));
  var texts = children.filter(function (child) {
    return typeof child === 'string';
  });
  if (texts.length) {
    properties.text = texts.join(' ');
  }
  return properties;
}

function getListenersMap(attributes) {
  var listeners = {};
  for (var attribute in attributes) {
    if (isEventAttribute(attribute)) {
      var event = attribute[2].toLocaleLowerCase() + attribute.slice(3);
      listeners[event] = attributes[attribute];
    }
  }
  return listeners;
}

function isEventAttribute(attribute) {
  return attribute.startsWith('on') && attribute.charCodeAt(2) <= 90;
}

var JSX = Object.freeze({
  createElement: createElement
});

var Action = function (_Widget4) {
  _inherits(Action, _Widget4);

  function Action() {
    _classCallCheck(this, Action);

    return _possibleConstructorReturn(this, (Action.__proto__ || Object.getPrototypeOf(Action)).apply(this, arguments));
  }

  _createClass(Action, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'select') {
        this._nativeListen(name, listening);
      } else {
        _get(Action.prototype.__proto__ || Object.getPrototypeOf(Action.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Action';
    }
  }]);

  return Action;
}(Widget);

NativeObject.defineProperties(Action.prototype, {
  image: { type: 'image', default: null },
  placementPriority: {
    type: ['choice', ['low', 'high', 'normal']],
    set: function (name, value) {
      this._nativeSet(name, value.toUpperCase());
      this._storeProperty(name, value);
    },

    default: 'normal'
  },
  title: { type: 'string', default: '' },
  win_symbol: { type: 'string', default: '' }
});

var Popup = function (_NativeObject13) {
  _inherits(Popup, _NativeObject13);

  function Popup() {
    _classCallCheck(this, Popup);

    return _possibleConstructorReturn(this, (Popup.__proto__ || Object.getPrototypeOf(Popup)).apply(this, arguments));
  }

  _createClass(Popup, [{
    key: 'open',
    value: function open() {
      if (this.isDisposed()) {
        throw new Error('Can not open a popup that was disposed');
      }
      this._nativeCall('open');
      return this;
    }
  }, {
    key: 'close',
    value: function close() {
      if (this._autoDispose) {
        this.dispose();
      }
      return this;
    }
  }]);

  return Popup;
}(NativeObject);

var ActionSheet = function (_Popup) {
  _inherits(ActionSheet, _Popup);

  function ActionSheet(properties) {
    _classCallCheck(this, ActionSheet);

    var _this37 = _possibleConstructorReturn(this, (ActionSheet.__proto__ || Object.getPrototypeOf(ActionSheet)).call(this));

    _this37._autoDispose = true;
    _this37._create('tabris.ActionSheet', properties);
    return _this37;
  }

  _createClass(ActionSheet, [{
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'close') {
        _get(ActionSheet.prototype.__proto__ || Object.getPrototypeOf(ActionSheet.prototype), '_trigger', this).call(this, 'close', event);
        this.dispose();
      } else {
        return _get(ActionSheet.prototype.__proto__ || Object.getPrototypeOf(ActionSheet.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'select') {
        this._nativeListen(name, listening);
      } else if (name === 'close') {
        this._nativeListen(name, listening);
      } else {
        _get(ActionSheet.prototype.__proto__ || Object.getPrototypeOf(ActionSheet.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.ActionSheet';
    }
  }]);

  return ActionSheet;
}(Popup);

NativeObject.defineProperties(ActionSheet.prototype, {
  title: { type: 'string', default: '' },
  message: { type: 'string', default: '' },
  actions: {
    type: {
      encode: function (value) {
        if (!Array.isArray(value)) {
          throw new Error('value is not an array');
        }
        return value.map(function (action) {
          var result = { title: '' + action.title };
          if ('image' in action) {
            result.image = types.image.encode(action.image);
          }
          if ('style' in action) {
            if (!['default', 'cancel', 'destructive'].includes(action.style)) {
              throw new Error('Invalid action style');
            }
            result.style = action.style;
          }
          return result;
        });
      }
    },
    default: function () {
      return [];
    }
  }
});

var ActivityIndicator = function (_Widget5) {
  _inherits(ActivityIndicator, _Widget5);

  function ActivityIndicator() {
    _classCallCheck(this, ActivityIndicator);

    return _possibleConstructorReturn(this, (ActivityIndicator.__proto__ || Object.getPrototypeOf(ActivityIndicator)).apply(this, arguments));
  }

  _createClass(ActivityIndicator, [{
    key: '_nativeType',
    get: function () {
      return 'tabris.ActivityIndicator';
    }
  }]);

  return ActivityIndicator;
}(Widget);

NativeObject.defineProperties(ActivityIndicator.prototype, {
  tintColor: { type: 'color' }
});

var AlertDialog = function (_Popup2) {
  _inherits(AlertDialog, _Popup2);

  function AlertDialog(properties) {
    _classCallCheck(this, AlertDialog);

    var _this39 = _possibleConstructorReturn(this, (AlertDialog.__proto__ || Object.getPrototypeOf(AlertDialog)).call(this));

    _this39._create('tabris.AlertDialog', properties);
    _this39._nativeListen('close', true);
    _this39._autoDispose = true;
    return _this39;
  }

  _createClass(AlertDialog, [{
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'close') {
        event.button = event.button || '';
        if (event.button) {
          _get(AlertDialog.prototype.__proto__ || Object.getPrototypeOf(AlertDialog.prototype), '_trigger', this).call(this, 'close' + capitalizeFirstChar(event.button), event);
        }
        _get(AlertDialog.prototype.__proto__ || Object.getPrototypeOf(AlertDialog.prototype), '_trigger', this).call(this, 'close', event);
        this.dispose();
      } else {
        return _get(AlertDialog.prototype.__proto__ || Object.getPrototypeOf(AlertDialog.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }]);

  return AlertDialog;
}(Popup);

NativeObject.defineProperties(AlertDialog.prototype, {
  title: { type: 'string', default: '' },
  message: { type: 'string', default: '' },
  buttons: {
    type: {
      encode: function (value) {
        if (typeof value !== 'object') {
          throw new Error('value is not an object');
        }
        var encoded = {};
        if ('ok' in value) {
          encoded.ok = value.ok + '';
        }
        if ('cancel' in value) {
          encoded.cancel = value.cancel + '';
        }
        if ('neutral' in value) {
          encoded.neutral = value.neutral + '';
        }
        return encoded;
      }
    },
    default: function () {
      return {};
    }
  }
});

var Button = function (_Widget6) {
  _inherits(Button, _Widget6);

  function Button() {
    _classCallCheck(this, Button);

    return _possibleConstructorReturn(this, (Button.__proto__ || Object.getPrototypeOf(Button)).apply(this, arguments));
  }

  _createClass(Button, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'select') {
        this._nativeListen(name, listening);
      } else {
        _get(Button.prototype.__proto__ || Object.getPrototypeOf(Button.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Button';
    }
  }]);

  return Button;
}(Widget);

NativeObject.defineProperties(Button.prototype, {
  alignment: { type: ['choice', ['left', 'right', 'center']], default: 'center' },
  image: { type: 'image', default: null },
  text: { type: 'string', default: '' },
  textColor: { type: 'color' }
});

var ImageData = function ImageData() {
  _classCallCheck(this, ImageData);

  if (arguments.length < 2) {
    throw new TypeError('Not enough arguments to ImageData');
  }
  var array = void 0,
      width = void 0,
      height = void 0;
  if (arguments[0] instanceof Uint8ClampedArray) {
    array = checkArray(arguments[0]);
    width = checkSize(arguments[1]);
    height = arguments.length > 2 ? checkSize(arguments[2]) : array.byteLength / 4 / width;
    if (array.byteLength !== width * height * 4) {
      throw new Error('Wrong array size');
    }
  } else {
    width = checkSize(arguments[0]);
    height = checkSize(arguments[1]);
    array = new Uint8ClampedArray(width * height * 4);
  }
  Object.defineProperties(this, {
    data: { value: array },
    width: { value: width },
    height: { value: height }
  });
};

function checkArray(array) {
  if (array.byteLength % 4 !== 0) {
    throw new Error('Illegal array length');
  }
  return array;
}

function checkSize(input) {
  var size = Math.floor(input);
  if (size <= 0 || !isFinite(size)) {
    throw new Error('Illegal size for ImageData');
  }
  return size;
}

var OPCODES = {
  arc: 1,
  arcTo: 2,
  beginPath: 3,
  bezierCurveTo: 4,
  clearRect: 5,
  closePath: 6,
  fill: 7,
  fillRect: 8,
  fillStyle: 9,
  fillText: 10,
  lineCap: 11,
  lineJoin: 12,
  lineTo: 13,
  lineWidth: 14,
  moveTo: 15,
  quadraticCurveTo: 16,
  rect: 17,
  restore: 18,
  rotate: 19,
  save: 20,
  scale: 21,
  setTransform: 22,
  stroke: 23,
  strokeRect: 24,
  strokeStyle: 25,
  strokeText: 26,
  textAlign: 27,
  textBaseline: 28,
  transform: 29,
  translate: 30,
  font: 31
};

var GC = function (_NativeObject14) {
  _inherits(GC, _NativeObject14);

  function GC(properties) {
    _classCallCheck(this, GC);

    var _this41 = _possibleConstructorReturn(this, (GC.__proto__ || Object.getPrototypeOf(GC)).call(this));

    _this41._create('tabris.GC', properties);
    _this41._operations = [];
    _this41._doubles = [];
    _this41._booleans = [];
    _this41._strings = [];
    _this41._ints = [];
    var listener = function () {
      return _this41.flush();
    };
    tabris.on('flush', listener);
    _this41.on('dispose', function () {
      return tabris.off('flush', listener);
    });
    return _this41;
  }

  _createClass(GC, [{
    key: 'init',
    value: function init(properties) {
      this._nativeCall('init', properties);
    }
  }, {
    key: 'getImageData',
    value: function getImageData(x, y, width, height) {
      var array = this._nativeCall('getImageData', { x: x, y: y, width: width, height: height });
      // TODO: remove when iOS returns a typed array
      return array instanceof Uint8ClampedArray ? array : new Uint8ClampedArray(array);
    }
  }, {
    key: 'putImageData',
    value: function putImageData(imageData, x, y) {
      this._nativeCall('putImageData', {
        data: imageData.data,
        width: imageData.width,
        height: imageData.height,
        x: x,
        y: y
      });
    }
  }, {
    key: 'addOperation',
    value: function addOperation(operation) {
      var opCode = OPCODES[operation];
      if (!opCode) {
        throw new Error('Invalid operation');
      }
      this._operations.push(opCode);
    }
  }, {
    key: 'addBoolean',
    value: function addBoolean() {
      Array.prototype.push.apply(this._booleans, arguments);
    }
  }, {
    key: 'addDouble',
    value: function addDouble() {
      Array.prototype.push.apply(this._doubles, arguments);
    }
  }, {
    key: 'addInt',
    value: function addInt() {
      Array.prototype.push.apply(this._ints, arguments);
    }
  }, {
    key: 'addString',
    value: function addString() {
      Array.prototype.push.apply(this._strings, arguments);
    }
  }, {
    key: 'flush',
    value: function flush() {
      if (this._operations.length > 0) {
        this._nativeCall('draw', { packedOperations: [this._operations, this._doubles, this._booleans, this._strings, this._ints] });
        this._operations = [];
        this._doubles = [];
        this._booleans = [];
        this._strings = [];
        this._ints = [];
      }
    }
  }]);

  return GC;
}(NativeObject);

NativeObject.defineProperties(GC.prototype, { parent: 'proxy' });

var CanvasContext = function () {
  function CanvasContext(gc) {
    _classCallCheck(this, CanvasContext);

    this._gc = gc;
    this._state = createState();
    this._savedStates = [];
    this.canvas = {
      width: 0,
      height: 0,
      style: {}
    };
    for (var name in properties) {
      defineProperty(this, name);
    }
  }

  _createClass(CanvasContext, [{
    key: 'measureText',
    value: function measureText(text) {
      // TODO: delegate to native function, once it is implemented (#56)
      return { width: text.length * 5 + 5 };
    }

    // ImageData operations

  }, {
    key: 'getImageData',
    value: function getImageData(x, y, width, height) {
      checkRequiredArgs(arguments, 4, 'CanvasContext.getImageData');
      this._gc.flush();
      // TODO check validity of args
      var array = this._gc.getImageData(x, y, width, height);
      return new ImageData(array, width, height);
    }
  }, {
    key: 'putImageData',
    value: function putImageData(imageData, x, y) {
      checkRequiredArgs(arguments, 3, 'CanvasContext.putImageData');
      this._gc.flush();
      this._gc.putImageData(imageData, x, y);
    }
  }, {
    key: 'createImageData',
    value: function createImageData(width, height) {
      if (arguments[0] instanceof ImageData) {
        var data = arguments[0];
        width = data.width;
        height = data.height;
      } else {
        checkRequiredArgs(arguments, 2, 'CanvasContext.createImageData');
      }
      return new ImageData(width, height);
    }
  }, {
    key: '_init',
    value: function _init(width, height) {
      this.canvas.width = width;
      this.canvas.height = height;
      this._gc.init({ width: width, height: height });
    }
  }]);

  return CanvasContext;
}();

// State operations

defineMethod('save', 0, function () {
  this._savedStates.push(Object.assign({}, this._state));
});

defineMethod('restore', 0, function () {
  this._state = this._savedStates.pop() || this._state;
});

// Path operations

defineMethod('beginPath');

defineMethod('closePath');

defineMethod('lineTo', 2, function (x, y) {
  this._gc.addDouble(x, y);
});

defineMethod('moveTo', 2, function (x, y) {
  this._gc.addDouble(x, y);
});

defineMethod('bezierCurveTo', 6, function (cp1x, cp1y, cp2x, cp2y, x, y) {
  this._gc.addDouble(cp1x, cp1y, cp2x, cp2y, x, y);
});

defineMethod('quadraticCurveTo', 4, function (cpx, cpy, x, y) {
  this._gc.addDouble(cpx, cpy, x, y);
});

defineMethod('rect', 4, function (x, y, width, height) {
  this._gc.addDouble(x, y, width, height);
});

defineMethod('arc', 5, function (x, y, radius, startAngle, endAngle, anticlockwise) {
  this._gc.addDouble(x, y, radius, startAngle, endAngle);
  this._gc.addBoolean(!!anticlockwise);
});

defineMethod('arcTo', 5, function (x1, y1, x2, y2, radius) {
  this._gc.addDouble(x1, y1, x2, y2, radius);
});

// Transformations

defineMethod('scale', 2, function (x, y) {
  this._gc.addDouble(x, y);
});

defineMethod('rotate', 1, function (angle) {
  this._gc.addDouble(angle);
});

defineMethod('translate', 2, function (x, y) {
  this._gc.addDouble(x, y);
});

defineMethod('transform', 6, function (a, b, c, d, e, f) {
  this._gc.addDouble(a, b, c, d, e, f);
});

defineMethod('setTransform', 6, function (a, b, c, d, e, f) {
  this._gc.addDouble(a, b, c, d, e, f);
});

// Drawing operations

defineMethod('clearRect', 4, function (x, y, width, height) {
  this._gc.addDouble(x, y, width, height);
});

defineMethod('fillRect', 4, function (x, y, width, height) {
  this._gc.addDouble(x, y, width, height);
});

defineMethod('strokeRect', 4, function (x, y, width, height) {
  this._gc.addDouble(x, y, width, height);
});

defineMethod('fillText', 3, function (text, x, y /* , maxWidth */) {
  this._gc.addString(text);
  this._gc.addBoolean(false, false, false);
  this._gc.addDouble(x, y);
});

defineMethod('strokeText', 3, function (text, x, y /* , maxWidth */) {
  this._gc.addString(text);
  this._gc.addBoolean(false, false, false);
  this._gc.addDouble(x, y);
});

defineMethod('fill');

defineMethod('stroke');

CanvasContext.getContext = function (canvas, width, height) {
  if (!canvas._gc) {
    canvas._gc = new GC({ parent: canvas });
  }
  if (!canvas._ctx) {
    canvas._ctx = new CanvasContext(canvas._gc);
  }
  canvas._ctx._init(width, height);
  return canvas._ctx;
};

var properties = {
  lineWidth: {
    init: 1,
    encode: function (value) {
      if (value > 0) {
        return value;
      }
      throw new Error(value);
    },

    decode: passThrough,
    addOperations: function (value) {
      this._gc.addDouble(value);
    }
  },
  lineCap: {
    init: 'butt',
    values: toObject(['butt', 'round', 'square']),
    encode: checkValue$1,
    decode: passThrough,
    addOperations: function (value) {
      this._gc.addString(value);
    }
  },
  lineJoin: {
    init: 'miter',
    values: toObject(['bevel', 'miter', 'round']),
    encode: checkValue$1,
    decode: passThrough,
    addOperations: function (value) {
      this._gc.addString(value);
    }
  },
  fillStyle: {
    init: [0, 0, 0, 255],
    encode: colorStringToArray,
    decode: colorArrayToString,
    addOperations: function (value) {
      this._gc.addInt(value[0], value[1], value[2], value[3]);
    }
  },
  strokeStyle: {
    init: [0, 0, 0, 255],
    encode: colorStringToArray,
    decode: colorArrayToString,
    addOperations: function (value) {
      this._gc.addInt(value[0], value[1], value[2], value[3]);
    }
  },
  textAlign: {
    init: 'start',
    values: toObject(['start', 'end', 'left', 'right', 'center']),
    encode: checkValue$1,
    decode: passThrough,
    addOperations: function (value) {
      this._gc.addString(value);
    }
  },
  textBaseline: {
    init: 'alphabetic',
    values: toObject(['top', 'hanging', 'middle', 'alphabetic', 'ideographic', 'bottom']),
    encode: checkValue$1,
    decode: passThrough,
    addOperations: function (value) {
      this._gc.addString(value);
    }
  },
  font: {
    init: { family: ['sans-serif'], size: 12, weight: 'normal', style: 'normal' },
    encode: fontStringToObject,
    decode: fontObjectToString,
    addOperations: function (font) {
      this._gc.addString(font.family.join(', '), font.style, font.weight);
      this._gc.addDouble(font.size);
    }
  }
};

function passThrough(value) {
  return value;
}

function checkValue$1(value) {
  if (value in this.values) {
    return value;
  }
  throw new Error(value);
}

function toObject(array) {
  var obj = {};
  array.forEach(function (name) {
    obj[name] = true;
  });
  return obj;
}

function createState() {
  var state = {};
  for (var name in properties) {
    state[name] = properties[name].init;
  }
  return state;
}

function defineMethod(name, reqArgCount, fn) {
  CanvasContext.prototype[name] = function () {
    checkRequiredArgs(arguments, reqArgCount, 'CanvasContext.' + name);
    this._gc.addOperation(name);
    if (fn) {
      fn.apply(this, arguments);
    }
  };
}

function defineProperty(context, name) {
  var prop = properties[name];
  Object.defineProperty(context, name, {
    get: function () {
      return prop.decode(context._state[name]);
    },
    set: function (value) {
      try {
        context._state[name] = prop.encode(value);
        context._gc.addOperation(name);
        prop.addOperations.call(context, context._state[name]);
      } catch (error$$1) {
        warn('Unsupported value for ' + name + ': ' + value);
      }
    }
  });
}

function checkRequiredArgs(args, nr, name) {
  if (args.length < nr) {
    throw new Error('Not enough arguments to ' + name);
  }
}

var Canvas = function (_Composite4) {
  _inherits(Canvas, _Composite4);

  function Canvas() {
    _classCallCheck(this, Canvas);

    return _possibleConstructorReturn(this, (Canvas.__proto__ || Object.getPrototypeOf(Canvas)).apply(this, arguments));
  }

  _createClass(Canvas, [{
    key: 'getContext',
    value: function getContext(type, width, height) {
      if (type === '2d') {
        return CanvasContext.getContext(this, width, height);
      }
      return null;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Canvas';
    }
  }]);

  return Canvas;
}(Composite);

var CheckBox = function (_Widget7) {
  _inherits(CheckBox, _Widget7);

  function CheckBox() {
    _classCallCheck(this, CheckBox);

    return _possibleConstructorReturn(this, (CheckBox.__proto__ || Object.getPrototypeOf(CheckBox)).apply(this, arguments));
  }

  _createClass(CheckBox, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'checkedChanged') {
        this._onoff('select', listening, this.$triggerChangeChecked);
      } else if (name === 'select') {
        this._nativeListen(name, listening);
      } else {
        _get(CheckBox.prototype.__proto__ || Object.getPrototypeOf(CheckBox.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '$triggerChangeChecked',
    value: function $triggerChangeChecked(_ref6) {
      var { checked: checked } = _ref6;

      this._triggerChangeEvent('checked', checked);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.CheckBox';
    }
  }]);

  return CheckBox;
}(Widget);

NativeObject.defineProperties(CheckBox.prototype, {
  text: { type: 'string', default: '' },
  checked: { type: 'boolean', nocache: true },
  textColor: { type: 'color' },
  tintColor: { type: 'color' },
  checkedTintColor: { type: 'color' }
});

var EVENT_TYPES$2 = ['refresh', 'select', 'scroll'];

var CollectionView = function (_Composite5) {
  _inherits(CollectionView, _Composite5);

  function CollectionView(properties) {
    _classCallCheck(this, CollectionView);

    var _this44 = _possibleConstructorReturn(this, (CollectionView.__proto__ || Object.getPrototypeOf(CollectionView)).call(this, properties));

    _this44._nativeListen('requestInfo', true);
    _this44._nativeListen('createCell', true);
    _this44._nativeListen('updateCell', true);
    tabris.on('flush', _this44.$flush, _this44);
    _this44.on('dispose', function () {
      return tabris.off('flush', _this44.$flush, _this44);
    });
    return _this44;
  }

  _createClass(CollectionView, [{
    key: 'load',
    value: function load(itemCount) {
      if (!isNumber$1(itemCount) || itemCount < 0) {
        throw new Error('Invalid itemCount');
      }
      this._storeProperty('itemCount', itemCount);
      this._needsReload = true;
    }
  }, {
    key: 'reveal',
    value: function reveal(index) {
      index = this.$checkIndex(index);
      if (index >= 0 && index < this.itemCount) {
        this.$flush();
        this._nativeCall('reveal', { index: index });
      }
    }
  }, {
    key: 'refresh',
    value: function refresh(index) {
      if (arguments.length === 0) {
        this.$flush();
        this._nativeCall('refresh', { index: 0, count: this.itemCount });
        return;
      }
      index = this.$checkIndex(index);
      if (index >= 0 && index < this.itemCount) {
        this.$flush();
        this._nativeCall('refresh', { index: index, count: 1 });
      }
    }
  }, {
    key: 'insert',
    value: function insert(index) {
      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      index = Math.min(Math.max(0, this.$checkIndex(index)), this.itemCount);
      if (!isNumber$1(count) || count <= 0) {
        throw new Error('Invalid insert count');
      }
      this._storeProperty('itemCount', this.itemCount + count);
      this.$flush();
      this._nativeCall('insert', { index: index, count: count });
    }
  }, {
    key: 'remove',
    value: function remove(index) {
      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      index = this.$checkIndex(index);
      if (isNumber$1(count) && count >= 0) {
        count = Math.min(count, this.itemCount - index);
      } else {
        throw new Error('Invalid remove count');
      }
      if (index >= 0 && index < this.itemCount && count > 0) {
        this._storeProperty('itemCount', this.itemCount - count);
        this.$flush();
        this._nativeCall('remove', { index: index, count: count });
      }
    }
  }, {
    key: '$flush',
    value: function $flush() {
      // Load new items if needed after all properties have been set
      // to avoid intercepting the aggregation of properties in set.
      if (this._needsReload) {
        delete this._needsReload;
        this._nativeCall('load', { itemCount: this.itemCount });
      }
    }
  }, {
    key: '$checkIndex',
    value: function $checkIndex(index) {
      if (!isNumber$1(index)) {
        throw new Error('Invalid index');
      }
      return index < 0 ? index + this.itemCount : index;
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'firstVisibleIndexChanged') {
        this._onoff('scroll', listening, triggerChangeFirstVisibleIndex);
      } else if (name === 'lastVisibleIndexChanged') {
        this._onoff('scroll', listening, triggerChangeLastVisibleIndex);
      } else if (EVENT_TYPES$2.includes(name)) {
        this._nativeListen(name, listening);
      } else {
        _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'requestInfo') {
        var _type = resolveProperty(this, 'cellType', event.index);
        var height = resolveProperty(this, 'cellHeight', event.index, _type);
        return {
          type: encodeCellType(this, _type),
          height: encodeCellHeight(height)
        };
      } else if (name === 'createCell') {
        var item = this.$createCell(event.type);
        return item.cid;
      } else if (name === 'updateCell') {
        this.updateCell(tabris._proxies.find(event.widget), event.index);
      } else if (name === 'select') {
        return _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), '_trigger', this).call(this, 'select', { index: event.index });
      } else {
        return _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '$createCell',
    value: function $createCell(type) {
      var cell = this.createCell(decodeCellType(this, type));
      if (!(cell instanceof Widget)) {
        throw new Error('Created cell is not a widget');
      }
      if (cell._parent) {
        throw new Error('Created cell already has a parent');
      }
      cell._parent = this;
      this._addChild(cell);
      cell._setParent = function () {
        return warn('Cannot re-parent collection view cell');
      };
      cell.dispose = function () {
        return warn('Cannot dispose of collection view cell');
      };
      return cell;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.CollectionView';
    }
  }]);

  return CollectionView;
}(Composite);

NativeObject.defineProperties(CollectionView.prototype, {
  itemCount: {
    type: 'natural',
    default: 0,
    set: function (name, value) {
      this._storeProperty(name, value);
      this._needsReload = true;
    }
  },
  cellType: {
    type: 'any', // string|function,
    default: null,
    set: function (name, value) {
      if (value !== this.cellType) {
        this._storeProperty(name, value);
        this._needsReload = true;
      }
    }
  },
  cellHeight: {
    type: 'any', // natural|auto|function
    default: 'auto',
    set: function (name, value) {
      if (value !== this.cellHeight) {
        this._storeProperty(name, value);
        this._needsReload = true;
      }
    }
  },
  createCell: {
    type: 'function',
    default: function () {
      return function () {
        return new Composite();
      };
    },
    set: function (name, value) {
      if (value !== this.createCell) {
        this._storeProperty(name, value);
        this._needsReload = true;
      }
    }
  },
  updateCell: {
    type: 'function',
    default: function () {
      return function () {};
    },
    set: function (name, value) {
      if (value !== this.updateCell) {
        this._storeProperty(name, value);
        this._needsReload = true;
      }
    }
  },
  refreshEnabled: {
    type: 'boolean',
    default: false
  },
  refreshIndicator: {
    type: 'boolean',
    nocache: true
  },
  refreshMessage: {
    type: 'string',
    default: ''
  },
  firstVisibleIndex: {
    type: 'number',
    readonly: true
  },
  lastVisibleIndex: {
    type: 'number',
    readonly: true
  },
  columnCount: {
    type: 'number',
    default: 1
  }
});

function resolveProperty(ctx, name) {
  var value = ctx[name];
  if (typeof value === 'function') {
    return value.apply(null, Array.prototype.slice.call(arguments, 2));
  }
  return value;
}

function encodeCellType(ctx, type) {
  var cellTypes = ctx._cellTypes || (ctx._cellTypes = []);
  var index = cellTypes.indexOf(type);
  if (index === -1) {
    index += cellTypes.push(type);
  }
  return index;
}

function decodeCellType(ctx, type) {
  var cellTypes = ctx._cellTypes || [];
  return cellTypes[type] || null;
}

function encodeCellHeight(value) {
  if (value === 'auto') {
    return -1;
  }
  if (isNumber$1(value)) {
    return Math.max(-1, value);
  }
  warn('Invalid cell height: ' + value);
}

var triggerChangeFirstVisibleIndex = createDelegate('firstVisibleIndex');
var triggerChangeLastVisibleIndex = createDelegate('lastVisibleIndex');

function createDelegate(prop) {
  return function () {
    var actual = this.get(prop);
    if (actual !== this['_prev:' + prop]) {
      this._triggerChangeEvent(prop, actual);
    }
    this['_prev:' + prop] = actual;
  };
}

function isNumber$1(value) {
  return typeof value === 'number' && isFinite(value);
}

var Crypto = function (_NativeObject15) {
  _inherits(Crypto, _NativeObject15);

  function Crypto() {
    _classCallCheck(this, Crypto);

    var _this45 = _possibleConstructorReturn(this, (Crypto.__proto__ || Object.getPrototypeOf(Crypto)).call(this));

    _this45._create('tabris.Crypto');
    return _this45;
  }

  _createClass(Crypto, [{
    key: 'getRandomValues',
    value: function getRandomValues(typedArray) {
      if (arguments.length === 0) {
        throw new Error('Not enough arguments to Crypto.getRandomValues');
      }
      if (!isIntArray(typedArray)) {
        throw new Error('Unsupported type in Crypto.getRandomValues');
      }
      var byteLength = typedArray.byteLength;
      var values = new Uint8Array(this._nativeCall('getRandomValues', { byteLength: byteLength }));
      if (values.byteLength !== byteLength) {
        throw new Error('Not enough random bytes available');
      }
      new Uint8Array(typedArray.buffer).set(values);
    }
  }]);

  return Crypto;
}(NativeObject);

function isIntArray(value) {
  return value instanceof Int8Array || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int16Array || value instanceof Uint16Array || value instanceof Int32Array || value instanceof Uint32Array;
}

var DateDialog = function (_Popup3) {
  _inherits(DateDialog, _Popup3);

  function DateDialog(properties) {
    _classCallCheck(this, DateDialog);

    var _this46 = _possibleConstructorReturn(this, (DateDialog.__proto__ || Object.getPrototypeOf(DateDialog)).call(this));

    _this46._create('tabris.DateDialog', properties);
    _this46._nativeListen('close', true);
    _this46._autoDispose = true;
    return _this46;
  }

  _createClass(DateDialog, [{
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'close') {
        this._handleCloseEvent(event);
      } else if (name === 'select') {
        event.date = new Date(event.date);
        _get(DateDialog.prototype.__proto__ || Object.getPrototypeOf(DateDialog.prototype), '_trigger', this).call(this, 'select', event);
        this._handleCloseEvent(event);
      } else {
        return _get(DateDialog.prototype.__proto__ || Object.getPrototypeOf(DateDialog.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '_handleCloseEvent',
    value: function _handleCloseEvent(event) {
      _get(DateDialog.prototype.__proto__ || Object.getPrototypeOf(DateDialog.prototype), '_trigger', this).call(this, 'close', event);
      this.dispose();
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'select') {
        this._nativeListen(name, listening);
      } else if (name === 'close') {
        this._nativeListen(name, listening);
      } else {
        _get(DateDialog.prototype.__proto__ || Object.getPrototypeOf(DateDialog.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.DateDialog';
    }
  }]);

  return DateDialog;
}(Popup);

NativeObject.defineProperties(DateDialog.prototype, {
  date: { type: 'any', default: undefined, set: setDate },
  maxDate: { type: 'any', default: undefined, set: setDate },
  minDate: { type: 'any', default: undefined, set: setDate }
});

function setDate(name, value) {
  if (value instanceof Date) {
    this._nativeSet(name, value.getTime());
    this._storeProperty(name, value);
  } else {
    throw new Error('date is not of type Date');
  }
}

var EVENT_TYPES$3 = ['load', 'zoom'];

var ImageView = function (_Widget8) {
  _inherits(ImageView, _Widget8);

  function ImageView() {
    _classCallCheck(this, ImageView);

    return _possibleConstructorReturn(this, (ImageView.__proto__ || Object.getPrototypeOf(ImageView)).apply(this, arguments));
  }

  _createClass(ImageView, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (EVENT_TYPES$3.includes(name)) {
        this._nativeListen(name, listening);
      } else if (name === 'zoomLevelChanged') {
        this._onoff('zoom', listening, this.$triggerChangeZoomLevel);
      } else {
        _get(ImageView.prototype.__proto__ || Object.getPrototypeOf(ImageView.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '$triggerChangeZoomLevel',
    value: function $triggerChangeZoomLevel(_ref7) {
      var { zoomLevel: zoomLevel } = _ref7;

      this._triggerChangeEvent('zoomLevel', zoomLevel);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.ImageView';
    }
  }]);

  return ImageView;
}(Widget);

NativeObject.defineProperties(ImageView.prototype, {
  image: { type: 'image', default: null },
  scaleMode: { type: ['choice', ['auto', 'fit', 'fill', 'stretch', 'none']], default: 'auto' },
  tintColor: {
    type: 'color',
    set: function (name, value) {
      this._nativeSet(name, value === undefined ? null : value);
      this._storeProperty(name, value);
    }
  },
  zoomEnabled: {
    type: 'boolean',
    default: false,
    set: function (name, value) {
      if (this.zoomEnabled !== value) {
        if (!value) {
          this.minZoomLevel = 1;
          this.maxZoomLevel = 3;
          this.zoomLevel = 1;
        }
        this._nativeSet(name, value);
        this._storeProperty(name, value);
      }
    }
  },
  zoomLevel: {
    type: 'number',
    nocache: true,
    set: function (name, value) {
      if (!this.zoomEnabled) {
        throw new Error('zoomLevel can not be set when zoomEnabled is false');
      }
      if (value < this.minZoomLevel) {
        throw new Error('zoomLevel can not be smaller than minZoomLevel');
      }
      if (value > this.maxZoomLevel) {
        throw new Error('zoomLevel can not be larger than maxZoomLevel');
      }
      this._nativeSet(name, value);
    }
  },
  minZoomLevel: {
    type: 'number',
    default: 1.0,
    set: function (name, value) {
      if (!this.zoomEnabled) {
        throw new Error('minZoomLevel can not be set when zoomEnabled is false');
      }
      if (value > this.maxZoomLevel) {
        throw new Error('minZoomLevel can not be larger than maxZoomLevel');
      }
      if (value > this.zoomLevel) {
        this.zoomLevel = value;
      }
      this._nativeSet(name, value);
      this._storeProperty(name, value);
    }
  },
  maxZoomLevel: {
    type: 'number',
    default: 3.0,
    set: function (name, value) {
      if (!this.zoomEnabled) {
        throw new Error('maxZoomLevel can not be set when zoomEnabled is false');
      }
      if (value < this.minZoomLevel) {
        throw new Error('maxZoomLevel can not be smaller than minZoomLevel');
      }
      if (value < this.zoomLevel) {
        this.zoomLevel = value;
      }
      this._nativeSet(name, value);
      this._storeProperty(name, value);
    }
  }
});

var InactivityTimer = function (_NativeObject16) {
  _inherits(InactivityTimer, _NativeObject16);

  function InactivityTimer(properties) {
    _classCallCheck(this, InactivityTimer);

    var _this48 = _possibleConstructorReturn(this, (InactivityTimer.__proto__ || Object.getPrototypeOf(InactivityTimer)).call(this));

    _this48._create('tabris.InactivityTimer', properties);
    _this48._nativeListen('timeout', true);
    return _this48;
  }

  _createClass(InactivityTimer, [{
    key: 'start',
    value: function start() {
      this._nativeCall('start');
    }
  }, {
    key: 'cancel',
    value: function cancel() {
      this._nativeCall('cancel');
    }
  }]);

  return InactivityTimer;
}(NativeObject);

NativeObject.defineProperties(InactivityTimer.prototype, {
  delay: {
    type: 'natural',
    default: 0
  }
});

var EVENT_TYPES$4 = ['input', 'accept', 'select'];

var SearchAction = function (_Widget9) {
  _inherits(SearchAction, _Widget9);

  function SearchAction() {
    _classCallCheck(this, SearchAction);

    return _possibleConstructorReturn(this, (SearchAction.__proto__ || Object.getPrototypeOf(SearchAction)).apply(this, arguments));
  }

  _createClass(SearchAction, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (EVENT_TYPES$4.includes(name)) {
        this._nativeListen(name, listening);
      } else {
        _get(SearchAction.prototype.__proto__ || Object.getPrototypeOf(SearchAction.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: 'open',
    value: function open() {
      this._nativeCall('open', {});
      return this;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.SearchAction';
    }
  }]);

  return SearchAction;
}(Widget);

NativeObject.defineProperties(SearchAction.prototype, {
  image: { type: 'image', default: null },
  placementPriority: { type: ['choice', ['low', 'high', 'normal']], default: 'normal' },
  title: { type: 'string', default: '' },
  proposals: {
    default: function () {
      return [];
    }
  },
  text: { type: 'string', nocache: true },
  message: { type: 'string', default: '' },
  win_symbol: { type: 'string', default: '' }
});

var NavigationView = function (_Composite6) {
  _inherits(NavigationView, _Composite6);

  function NavigationView(properties) {
    _classCallCheck(this, NavigationView);

    var _this50 = _possibleConstructorReturn(this, (NavigationView.__proto__ || Object.getPrototypeOf(NavigationView)).call(this, properties));

    _this50._nativeListen('backNavigation', true);
    return _this50;
  }

  _createClass(NavigationView, [{
    key: '_acceptChild',
    value: function _acceptChild(child) {
      return child instanceof Page || child instanceof Action || child instanceof SearchAction;
    }
  }, {
    key: '_addChild',
    value: function _addChild(child, index) {
      var isTopPage = child instanceof Page && typeof index !== 'number' || index === this.pages().length;
      if (isTopPage) {
        this.$triggerDisappear();
      }
      _get(NavigationView.prototype.__proto__ || Object.getPrototypeOf(NavigationView.prototype), '_addChild', this).call(this, child, index);
      if (isTopPage) {
        this.$triggerAppear();
      }
    }
  }, {
    key: '_removeChild',
    value: function _removeChild(child) {
      var isTopPage = child instanceof Page && child === this.pages().last();
      if (isTopPage) {
        this.$triggerDisappear();
      }
      _get(NavigationView.prototype.__proto__ || Object.getPrototypeOf(NavigationView.prototype), '_removeChild', this).call(this, child);
      if (isTopPage) {
        this.$triggerAppear();
      }
    }
  }, {
    key: '$handleBackNavigation',
    value: function $handleBackNavigation() {
      this.$pop(this.pages().last());
    }
  }, {
    key: '$pop',
    value: function $pop(page) {
      if (page && page.autoDispose) {
        page.dispose();
      } else if (page) {
        page._setParent(null);
      }
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'topToolbarHeightChanged' || name === 'bottomToolbarHeightChanged') {
        this._nativeListen(name, listening);
      } else {
        _get(NavigationView.prototype.__proto__ || Object.getPrototypeOf(NavigationView.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'backNavigation') {
        this.$handleBackNavigation();
      } else if (name === 'topToolbarHeightChanged') {
        this._triggerChangeEvent('topToolbarHeight', event.topToolbarHeight);
      } else if (name === 'bottomToolbarHeightChanged') {
        this._triggerChangeEvent('bottomToolbarHeight', event.bottomToolbarHeight);
      } else {
        return _get(NavigationView.prototype.__proto__ || Object.getPrototypeOf(NavigationView.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '$triggerAppear',
    value: function $triggerAppear() {
      var topPage = this.pages().last();
      if (topPage) {
        topPage.$trigger('appear');
      }
    }
  }, {
    key: '$triggerDisappear',
    value: function $triggerDisappear() {
      var topPage = this.pages().last();
      if (topPage) {
        topPage.$trigger('disappear');
      }
    }
  }, {
    key: 'pages',
    value: function pages(selector) {
      return this.children(selector).filter(function (child) {
        return child instanceof Page;
      });
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.NavigationView';
    }
  }]);

  return NavigationView;
}(Composite);

NativeObject.defineProperties(NavigationView.prototype, {
  drawerActionVisible: { type: 'boolean', default: false },
  toolbarVisible: { type: 'boolean', default: true },
  toolbarColor: { type: 'color' },
  topToolbarHeight: { readonly: true },
  bottomToolbarHeight: { readonly: true },
  titleTextColor: { type: 'color' },
  actionColor: { type: 'color' },
  actionTextColor: { type: 'color' },
  pageAnimation: { type: ['choice', ['default', 'none']], default: 'default' },
  win_toolbarTheme: { type: ['choice', ['default', 'light', 'dark']], default: 'default' },
  win_toolbarOverflowTheme: { type: ['choice', ['default', 'light', 'dark']], default: 'default' },
  win_drawerActionTheme: { type: ['choice', ['default', 'light', 'dark']], default: 'default' },
  win_drawerActionBackground: { type: 'color' }
});

var Page = function (_Composite7) {
  _inherits(Page, _Composite7);

  function Page() {
    _classCallCheck(this, Page);

    return _possibleConstructorReturn(this, (Page.__proto__ || Object.getPrototypeOf(Page)).apply(this, arguments));
  }

  _createClass(Page, [{
    key: 'insertBefore',
    value: function insertBefore() {
      throw new Error('insertBefore not supported on Page');
    }
  }, {
    key: 'insertAfter',
    value: function insertAfter() {
      throw new Error('insertAfter not supported on Page');
    }
  }, {
    key: '_setParent',
    value: function _setParent(parent, index) {
      if (parent && !(parent instanceof NavigationView)) {
        throw new Error('Page could not be appended to ' + parent);
      }
      _get(Page.prototype.__proto__ || Object.getPrototypeOf(Page.prototype), '_setParent', this).call(this, parent, index);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Page';
    }
  }]);

  return Page;
}(Composite);

NativeObject.defineProperties(Page.prototype, {
  image: { type: 'image', default: null },
  title: { type: 'string', default: '' },
  autoDispose: { type: 'boolean', default: true }
});

var Picker = function (_Widget10) {
  _inherits(Picker, _Widget10);

  function Picker(properties) {
    _classCallCheck(this, Picker);

    var _this52 = _possibleConstructorReturn(this, (Picker.__proto__ || Object.getPrototypeOf(Picker)).call(this, Object.assign({ selectionIndex: 0 }, properties)));

    tabris.on('flush', _this52.$flush, _this52);
    _this52.on('dispose', function () {
      return tabris.off('flush', _this52.$flush, _this52);
    });
    return _this52;
  }

  _createClass(Picker, [{
    key: '$flush',
    value: function $flush() {
      if (this.$needsUpdateItems) {
        var items = new Array(this.itemCount);
        for (var index = 0; index < items.length; index++) {
          items[index] = this.itemText(index);
        }
        this._nativeSet('items', items);
        tabris._nativeBridge.flush();
        delete this.$needsUpdateItems;
      }
      if (this.$newSelectionIndex >= 0) {
        this._nativeSet('selectionIndex', this.$newSelectionIndex);
        this._triggerChangeEvent('selectionIndex', this.$newSelectionIndex);
        tabris._nativeBridge.flush();
        delete this.$newSelectionIndex;
      }
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'select') {
        this._nativeListen(name, listening);
      } else if (name === 'selectionIndexChanged') {
        this._onoff('select', listening, this.$triggerSelectionIndexChanged);
      } else {
        _get(Picker.prototype.__proto__ || Object.getPrototypeOf(Picker.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'select') {
        return _get(Picker.prototype.__proto__ || Object.getPrototypeOf(Picker.prototype), '_trigger', this).call(this, 'select', { index: event.selectionIndex });
      }
      return _get(Picker.prototype.__proto__ || Object.getPrototypeOf(Picker.prototype), '_trigger', this).call(this, name, event);
    }
  }, {
    key: '$triggerSelectionIndexChanged',
    value: function $triggerSelectionIndexChanged(_ref8) {
      var { index: index } = _ref8;

      this._triggerChangeEvent('selectionIndex', index);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Picker';
    }
  }]);

  return Picker;
}(Widget);

NativeObject.defineProperties(Picker.prototype, {
  itemCount: {
    type: 'natural',
    default: 0,
    set: function (name, value) {
      this._storeProperty(name, value);
      this.$needsUpdateItems = true;
    }
  },
  itemText: {
    type: 'function',
    default: function () {
      return function () {
        return '';
      };
    },
    set: function (name, value) {
      this.$needsUpdateItems = true;
      this._storeProperty(name, value);
    }
  },
  selectionIndex: {
    type: 'natural',
    default: 0,
    set: function (name, value) {
      this.$newSelectionIndex = value;
    },
    get: function (name) {
      return this.$newSelectionIndex >= 0 ? this.$newSelectionIndex : this._nativeGet(name);
    }
  },
  fillColor: { type: 'color' },
  borderColor: { type: 'color' },
  textColor: { type: 'color' }
});

var Pbkdf2 = function (_NativeObject17) {
  _inherits(Pbkdf2, _NativeObject17);

  function Pbkdf2() {
    _classCallCheck(this, Pbkdf2);

    var _this53 = _possibleConstructorReturn(this, (Pbkdf2.__proto__ || Object.getPrototypeOf(Pbkdf2)).call(this));

    _this53._create('tabris.pkcs5.Pbkdf2');
    _this53._nativeListen('done', true);
    return _this53;
  }

  _createClass(Pbkdf2, [{
    key: 'start',
    value: function start(parameters) {
      this._nativeCall('start', parameters);
    }
  }]);

  return Pbkdf2;
}(NativeObject);

var Pkcs5 = function () {
  function Pkcs5() {
    _classCallCheck(this, Pkcs5);
  }

  _createClass(Pkcs5, [{
    key: 'pbkdf2',
    value: function pbkdf2(password, salt, iterationCount, keySize) {
      var _arguments14 = arguments;

      return new Promise(function (resolve) {
        if (_arguments14.length < 4) {
          throw new Error('Not enough arguments to pbkdf2');
        }
        if (typeof password !== 'string') {
          throw new Error('Invalid type for password in pbkdf2');
        }
        if (!(salt instanceof Uint8Array)) {
          throw new Error('Invalid type for salt in pbkdf2');
        }
        if (typeof iterationCount !== 'number' || iterationCount <= 0) {
          throw new Error('Invalid number for iterationCount in pbkdf2');
        }
        if (typeof keySize !== 'number' || keySize <= 0) {
          throw new Error('Invalid number for keySize in pbkdf2');
        }
        var pbkdf2 = new Pbkdf2();
        pbkdf2.on('done', function (event) {
          pbkdf2.dispose();
          resolve(event.key);
        });
        // TODO: transfer salt as typed array once iOS 9 support is discontinued
        pbkdf2.start({ password: password, salt: toArray(salt), iterationCount: iterationCount, keySize: keySize });
      });
    }
  }]);

  return Pkcs5;
}();

function toArray(typedArray) {
  var array = new Array(typedArray.length);
  for (var i = 0; i < typedArray.length; i++) {
    array[i] = typedArray[i];
  }
  return array;
}

var ProgressEvent = function (_Event) {
  _inherits(ProgressEvent, _Event);

  function ProgressEvent(type, config) {
    _classCallCheck(this, ProgressEvent);

    if (arguments.length < 1) {
      throw new Error('Not enough arguments to ProgressEvent');
    }

    var _this54 = _possibleConstructorReturn(this, (ProgressEvent.__proto__ || Object.getPrototypeOf(ProgressEvent)).call(this, type, config));

    _this54.$lengthComputable = config && config.lengthComputable || false;
    _this54.$loaded = config && config.loaded || 0;
    _this54.$total = config && config.total || 0;
    return _this54;
  }

  _createClass(ProgressEvent, [{
    key: 'lengthComputable',
    get: function () {
      return this.$lengthComputable;
    }
  }, {
    key: 'loaded',
    get: function () {
      return this.$loaded;
    }
  }, {
    key: 'total',
    get: function () {
      return this.$total;
    }
  }]);

  return ProgressEvent;
}(Event);

var ProgressBar = function (_Widget11) {
  _inherits(ProgressBar, _Widget11);

  function ProgressBar() {
    _classCallCheck(this, ProgressBar);

    return _possibleConstructorReturn(this, (ProgressBar.__proto__ || Object.getPrototypeOf(ProgressBar)).apply(this, arguments));
  }

  _createClass(ProgressBar, [{
    key: '_nativeType',
    get: function () {
      return 'tabris.ProgressBar';
    }
  }]);

  return ProgressBar;
}(Widget);

NativeObject.defineProperties(ProgressBar.prototype, {
  minimum: { type: 'integer', default: 0 },
  maximum: { type: 'integer', default: 100 },
  tintColor: { type: 'color' },
  selection: { type: 'integer', default: 0 },
  state: { type: ['choice', ['normal', 'paused', 'error']], default: 'normal' }
});

var RadioButton = function (_Widget12) {
  _inherits(RadioButton, _Widget12);

  function RadioButton() {
    _classCallCheck(this, RadioButton);

    return _possibleConstructorReturn(this, (RadioButton.__proto__ || Object.getPrototypeOf(RadioButton)).apply(this, arguments));
  }

  _createClass(RadioButton, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'select') {
        this._nativeListen(name, listening);
      } else if (name === 'checkedChanged') {
        this._onoff('select', listening, this.$triggerChangeChecked);
      } else {
        _get(RadioButton.prototype.__proto__ || Object.getPrototypeOf(RadioButton.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '$triggerChangeChecked',
    value: function $triggerChangeChecked(_ref9) {
      var { checked: checked } = _ref9;

      this._triggerChangeEvent('checked', checked);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.RadioButton';
    }
  }]);

  return RadioButton;
}(Widget);

NativeObject.defineProperties(RadioButton.prototype, {
  text: { type: 'string', default: '' },
  checked: { type: 'boolean', nocache: true },
  textColor: { type: 'color' },
  tintColor: { type: 'color' },
  checkedTintColor: { type: 'color' }
});

var RefreshComposite = function (_Composite8) {
  _inherits(RefreshComposite, _Composite8);

  function RefreshComposite() {
    _classCallCheck(this, RefreshComposite);

    return _possibleConstructorReturn(this, (RefreshComposite.__proto__ || Object.getPrototypeOf(RefreshComposite)).apply(this, arguments));
  }

  _createClass(RefreshComposite, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'refresh') {
        this._nativeListen(name, listening);
      } else {
        _get(RefreshComposite.prototype.__proto__ || Object.getPrototypeOf(RefreshComposite.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.RefreshComposite';
    }
  }]);

  return RefreshComposite;
}(Composite);

NativeObject.defineProperties(RefreshComposite.prototype, {

  refreshEnabled: {
    type: 'boolean',
    default: true
  },
  refreshIndicator: {
    type: 'boolean',
    nocache: true
  },
  refreshMessage: {
    type: 'string',
    default: ''
  }

});

var EVENT_TYPES$5 = ['scrollX', 'scrollY'];

var ScrollView = function (_Composite9) {
  _inherits(ScrollView, _Composite9);

  function ScrollView() {
    _classCallCheck(this, ScrollView);

    return _possibleConstructorReturn(this, (ScrollView.__proto__ || Object.getPrototypeOf(ScrollView)).apply(this, arguments));
  }

  _createClass(ScrollView, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (EVENT_TYPES$5.includes(name)) {
        this._nativeListen(name, listening);
      } else if (name === 'offsetXChanged') {
        this._onoff('scrollX', listening, this.$triggerChangeOffsetX);
      } else if (name === 'offsetYChanged') {
        this._onoff('scrollY', listening, this.$triggerChangeOffsetY);
      } else {
        _get(ScrollView.prototype.__proto__ || Object.getPrototypeOf(ScrollView.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '$triggerChangeOffsetX',
    value: function $triggerChangeOffsetX(_ref10) {
      var { offset: offset } = _ref10;

      this._triggerChangeEvent('offsetX', offset);
    }
  }, {
    key: '$triggerChangeOffsetY',
    value: function $triggerChangeOffsetY(_ref11) {
      var { offset: offset } = _ref11;

      this._triggerChangeEvent('offsetY', offset);
    }
  }, {
    key: 'scrollToY',
    value: function scrollToY(offset, options) {
      this._nativeCall('scrollToY', {
        offset: offset,
        animate: options && 'animate' in options ? !!options.animate : true
      });
      return this;
    }
  }, {
    key: 'scrollToX',
    value: function scrollToX(offset, options) {
      this._nativeCall('scrollToX', {
        offset: offset,
        animate: options && 'animate' in options ? !!options.animate : true
      });
      return this;
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.ScrollView';
    }
  }]);

  return ScrollView;
}(Composite);

NativeObject.defineProperties(ScrollView.prototype, {
  direction: {
    type: ['choice', ['horizontal', 'vertical']],
    default: 'vertical'
  },
  offsetX: { type: 'number', nocache: true, readonly: true },
  offsetY: { type: 'number', nocache: true, readonly: true }
});

var Slider = function (_Widget13) {
  _inherits(Slider, _Widget13);

  function Slider() {
    _classCallCheck(this, Slider);

    return _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).apply(this, arguments));
  }

  _createClass(Slider, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'select') {
        this._nativeListen(name, listening);
      } else if (name === 'selectionChanged') {
        this._onoff('select', listening, this.$triggerChangeSelection);
      } else {
        _get(Slider.prototype.__proto__ || Object.getPrototypeOf(Slider.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '$triggerChangeSelection',
    value: function $triggerChangeSelection(_ref12) {
      var { selection: selection } = _ref12;

      this._triggerChangeEvent('selection', selection);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Slider';
    }
  }]);

  return Slider;
}(Widget);

NativeObject.defineProperties(Slider.prototype, {
  minimum: { type: 'integer', default: 0 },
  maximum: { type: 'integer', default: 100 },
  selection: { type: 'integer', nocache: true },
  tintColor: { type: 'color' }
});

var Switch = function (_Widget14) {
  _inherits(Switch, _Widget14);

  function Switch() {
    _classCallCheck(this, Switch);

    return _possibleConstructorReturn(this, (Switch.__proto__ || Object.getPrototypeOf(Switch)).apply(this, arguments));
  }

  _createClass(Switch, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'select') {
        this._nativeListen(name, listening);
      } else if (name === 'checkedChanged') {
        this._onoff('select', listening, this.$triggerChangeChecked);
      } else {
        _get(Switch.prototype.__proto__ || Object.getPrototypeOf(Switch.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '$triggerChangeChecked',
    value: function $triggerChangeChecked(_ref13) {
      var { checked: checked } = _ref13;

      this._triggerChangeEvent('checked', checked);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Switch';
    }
  }]);

  return Switch;
}(Widget);

NativeObject.defineProperties(Switch.prototype, {
  checked: { type: 'boolean', nocache: true },
  thumbOnColor: { type: 'color' },
  thumbOffColor: { type: 'color' },
  trackOnColor: { type: 'color' },
  trackOffColor: { type: 'color' }
});

var EVENT_TYPES$6 = ['select', 'scroll'];

var TabFolder = function (_Composite10) {
  _inherits(TabFolder, _Composite10);

  function TabFolder() {
    _classCallCheck(this, TabFolder);

    return _possibleConstructorReturn(this, (TabFolder.__proto__ || Object.getPrototypeOf(TabFolder)).apply(this, arguments));
  }

  _createClass(TabFolder, [{
    key: '_acceptChild',
    value: function _acceptChild(child) {
      return child instanceof Tab;
    }
  }, {
    key: '_addChild',
    value: function _addChild(child, index) {
      _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_addChild', this).call(this, child, index);
      if (this.$children.indexOf(child) === 0) {
        child.$trigger('appear');
        this.$previousSelection = child;
      }
    }
  }, {
    key: '_removeChild',
    value: function _removeChild(child) {
      if (!this._inDispose) {
        var childIndex = this.$children.indexOf(child);
        var rightNeighbor = this.$children[childIndex + 1];
        var leftNeighbor = this.$children[childIndex - 1];
        var newSelection = rightNeighbor || leftNeighbor;
        if (newSelection) {
          this.selection = newSelection;
        } else {
          this._triggerChangeEvent('selection', null);
        }
      }
      _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_removeChild', this).call(this, child);
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (EVENT_TYPES$6.includes(name)) {
        this._nativeListen(name, listening);
      } else if (name === 'selectionChanged') {
        this._onoff('select', listening, this.$triggerChangeSelection);
      } else {
        _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'select') {
        var selection = tabris._proxies.find(event.selection);
        return _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_trigger', this).call(this, 'select', { selection: selection });
      }
      if (name === 'scroll') {
        var _selection = event.selection ? tabris._proxies.find(event.selection) : null;
        return _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_trigger', this).call(this, 'scroll', { selection: _selection, offset: event.offset });
      }
      return _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_trigger', this).call(this, name, event);
    }
  }, {
    key: '_triggerChangeEvent',
    value: function _triggerChangeEvent(name, value) {
      _get(TabFolder.prototype.__proto__ || Object.getPrototypeOf(TabFolder.prototype), '_triggerChangeEvent', this).call(this, name, value);
      if (name === 'selection') {
        if (this.$previousSelection) {
          this.$previousSelection._trigger('disappear');
        }
        if (value) {
          value._trigger('appear');
        }
        this.$previousSelection = value;
      }
    }
  }, {
    key: '$triggerChangeSelection',
    value: function $triggerChangeSelection(_ref14) {
      var { selection: selection } = _ref14;

      this._triggerChangeEvent('selection', selection);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.TabFolder';
    }
  }]);

  return TabFolder;
}(Composite);

NativeObject.defineProperties(TabFolder.prototype, {
  paging: { type: 'boolean', default: false },
  tabBarLocation: { type: ['choice', ['top', 'bottom', 'hidden', 'auto']], default: 'auto' },
  tabMode: { type: ['choice', ['fixed', 'scrollable']], default: 'fixed' },
  selection: {
    set: function (name, tab) {
      if (this._children().indexOf(tab) < 0) {
        warn('Can not set TabFolder selection to ' + tab);
        return;
      }
      this._nativeSet('selection', tab.cid);
      this._triggerChangeEvent('selection', tab);
    },
    get: function () {
      if (!this.$children.length) {
        return null;
      }
      var selection = this._nativeGet('selection');
      return selection ? tabris._proxies.find(selection) : null;
    }
  },
  textColor: { type: 'color' },
  win_tabBarTheme: { type: ['choice', ['default', 'light', 'dark']], default: 'default' }
});

var Tab = function (_Composite11) {
  _inherits(Tab, _Composite11);

  function Tab() {
    _classCallCheck(this, Tab);

    return _possibleConstructorReturn(this, (Tab.__proto__ || Object.getPrototypeOf(Tab)).apply(this, arguments));
  }

  _createClass(Tab, [{
    key: '_setParent',
    value: function _setParent(parent, index) {
      if (parent && !(parent instanceof TabFolder)) {
        throw new Error('Tab could not be appended to ' + parent);
      }
      _get(Tab.prototype.__proto__ || Object.getPrototypeOf(Tab.prototype), '_setParent', this).call(this, parent, index);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Tab';
    }
  }]);

  return Tab;
}(Composite);

NativeObject.defineProperties(Tab.prototype, {
  title: { type: 'string', default: '' },
  image: { type: 'image', default: null },
  selectedImage: { type: 'image', default: null },
  badge: { type: 'string', default: '' }
});

var EVENT_TYPES$7 = ['focus', 'blur', 'accept', 'input'];

var TextInput = function (_Widget15) {
  _inherits(TextInput, _Widget15);

  function TextInput() {
    _classCallCheck(this, TextInput);

    return _possibleConstructorReturn(this, (TextInput.__proto__ || Object.getPrototypeOf(TextInput)).apply(this, arguments));
  }

  _createClass(TextInput, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (EVENT_TYPES$7.includes(name)) {
        this._nativeListen(name, listening);
      } else if (name === 'textChanged') {
        this._onoff('input', listening, this.$triggerChangeSelection);
      } else {
        _get(TextInput.prototype.__proto__ || Object.getPrototypeOf(TextInput.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '$triggerChangeSelection',
    value: function $triggerChangeSelection(_ref15) {
      var { text: text } = _ref15;

      this._triggerChangeEvent('text', text);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.TextInput';
    }
  }]);

  return TextInput;
}(Widget);

NativeObject.defineProperties(TextInput.prototype, {
  type: { type: ['choice', ['default', 'password', 'search', 'multiline']] },
  text: { type: 'string', nocache: true },
  message: { type: 'string', default: '' },
  editable: { type: 'boolean', default: true },
  keepFocus: { type: 'boolean', default: false },
  alignment: { type: ['choice', ['left', 'center', 'right']], default: 'left' },
  autoCorrect: { type: 'boolean', default: false },
  autoCapitalize: {
    type: ['choice', [true, false, 'none', 'sentence', 'word', 'all']],
    default: false,
    set: function (name, value) {
      if (value === true) {
        this._nativeSet(name, 'all');
      } else if (value === false) {
        this._nativeSet(name, 'none');
      } else {
        this._nativeSet(name, value);
      }
      this._storeProperty(name, value);
    }
  },
  keyboard: {
    type: ['choice', ['ascii', 'decimal', 'email', 'number', 'numbersAndPunctuation', 'phone', 'url', 'default']],
    default: 'default'
  },
  enterKeyType: {
    type: ['choice', ['default', 'done', 'next', 'send', 'search', 'go']],
    default: 'default'
  },
  focused: { type: 'boolean', nocache: true },
  fillColor: { type: 'color' },
  borderColor: { type: 'color' },
  textColor: { type: 'color' },
  revealPassword: { type: 'boolean' },
  cursorColor: { type: 'color' }
});

var TextView = function (_Widget16) {
  _inherits(TextView, _Widget16);

  function TextView() {
    _classCallCheck(this, TextView);

    return _possibleConstructorReturn(this, (TextView.__proto__ || Object.getPrototypeOf(TextView)).apply(this, arguments));
  }

  _createClass(TextView, [{
    key: '_nativeType',
    get: function () {
      return 'tabris.TextView';
    }
  }]);

  return TextView;
}(Widget);

NativeObject.defineProperties(TextView.prototype, {
  alignment: { type: ['choice', ['left', 'right', 'center']], default: 'left' },
  markupEnabled: { type: 'boolean', default: false }, // TODO: readonly
  lineSpacing: { type: 'number', default: 1 },
  selectable: { type: 'boolean', default: false },
  maxLines: {
    type: ['nullable', 'natural'],
    default: null,
    set: function (name, value) {
      this._nativeSet(name, value <= 0 ? null : value);
      this._storeProperty(name, value);
    }
  },
  text: { type: 'string', default: '' },
  textColor: { type: 'color' }
});

var TimeDialog = function (_Popup4) {
  _inherits(TimeDialog, _Popup4);

  function TimeDialog(properties) {
    _classCallCheck(this, TimeDialog);

    var _this65 = _possibleConstructorReturn(this, (TimeDialog.__proto__ || Object.getPrototypeOf(TimeDialog)).call(this));

    _this65._create('tabris.TimeDialog', properties);
    _this65._nativeListen('close', true);
    _this65._autoDispose = true;
    return _this65;
  }

  _createClass(TimeDialog, [{
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'close') {
        this._handleCloseEvent(event);
      } else if (name === 'select') {
        event.date = new Date(event.date);
        _get(TimeDialog.prototype.__proto__ || Object.getPrototypeOf(TimeDialog.prototype), '_trigger', this).call(this, 'select', event);
        this._handleCloseEvent(event);
      } else {
        return _get(TimeDialog.prototype.__proto__ || Object.getPrototypeOf(TimeDialog.prototype), '_trigger', this).call(this, name, event);
      }
    }
  }, {
    key: '_handleCloseEvent',
    value: function _handleCloseEvent(event) {
      _get(TimeDialog.prototype.__proto__ || Object.getPrototypeOf(TimeDialog.prototype), '_trigger', this).call(this, 'close', event);
      this.dispose();
    }
  }, {
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'select') {
        this._nativeListen(name, listening);
      } else if (name === 'close') {
        this._nativeListen(name, listening);
      } else {
        _get(TimeDialog.prototype.__proto__ || Object.getPrototypeOf(TimeDialog.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.TimeDialog';
    }
  }]);

  return TimeDialog;
}(Popup);

NativeObject.defineProperties(TimeDialog.prototype, {
  date: { type: 'any', default: undefined, set: setDate$1 }
});

function setDate$1(name, value) {
  if (value instanceof Date) {
    this._nativeSet(name, value.getTime());
    this._storeProperty(name, value);
  } else {
    throw new Error('date is not of type Date');
  }
}

var ToggleButton = function (_Widget17) {
  _inherits(ToggleButton, _Widget17);

  function ToggleButton() {
    _classCallCheck(this, ToggleButton);

    return _possibleConstructorReturn(this, (ToggleButton.__proto__ || Object.getPrototypeOf(ToggleButton)).apply(this, arguments));
  }

  _createClass(ToggleButton, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'select') {
        this._nativeListen(name, listening);
      } else if (name === 'checkedChanged') {
        this._onoff('select', listening, this.$triggerChangeChecked);
      } else {
        _get(ToggleButton.prototype.__proto__ || Object.getPrototypeOf(ToggleButton.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '$triggerChangeChecked',
    value: function $triggerChangeChecked(_ref16) {
      var { checked: checked } = _ref16;

      this._triggerChangeEvent('checked', checked);
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.ToggleButton';
    }
  }]);

  return ToggleButton;
}(Widget);

NativeObject.defineProperties(ToggleButton.prototype, {
  text: { type: 'string', default: '' },
  image: { type: 'image', default: null },
  checked: { type: 'boolean', nocache: true },
  alignment: { type: ['choice', ['left', 'right', 'center']], default: 'center' },
  textColor: { type: 'color' }
});

var Video = function (_Widget18) {
  _inherits(Video, _Widget18);

  function Video() {
    _classCallCheck(this, Video);

    return _possibleConstructorReturn(this, (Video.__proto__ || Object.getPrototypeOf(Video)).apply(this, arguments));
  }

  _createClass(Video, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (name === 'stateChanged' || name === 'speedChanged') {
        this._nativeListen(name, listening);
      } else {
        _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: '_trigger',
    value: function _trigger(name, event) {
      if (name === 'stateChanged') {
        return this._triggerChangeEvent('state', event.state);
      } else if (name === 'speedChanged') {
        return this._triggerChangeEvent('speed', event.speed);
      }
      return _get(Video.prototype.__proto__ || Object.getPrototypeOf(Video.prototype), '_trigger', this).call(this, name, event);
    }
  }, {
    key: 'pause',
    value: function pause() {
      this._nativeCall('pause');
    }
  }, {
    key: 'play',
    value: function play(speed) {
      this._nativeCall('play', {
        speed: arguments.length > 0 ? types.number.encode(speed) : 1
      });
    }
  }, {
    key: 'seek',
    value: function seek(position) {
      this._nativeCall('seek', { position: types.number.encode(position) });
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.Video';
    }
  }]);

  return Video;
}(Widget);

NativeObject.defineProperties(Video.prototype, {
  url: { type: 'string', default: '' },
  controlsVisible: { type: 'boolean', default: true },
  autoPlay: { type: 'boolean', default: true },
  speed: { readonly: true },
  position: { readonly: true },
  duration: { readonly: true },
  state: { readonly: true }
});

var EVENT_TYPES$8 = ['navigate', 'load', 'download', 'message'];

var WebView = function (_Widget19) {
  _inherits(WebView, _Widget19);

  function WebView() {
    _classCallCheck(this, WebView);

    return _possibleConstructorReturn(this, (WebView.__proto__ || Object.getPrototypeOf(WebView)).apply(this, arguments));
  }

  _createClass(WebView, [{
    key: '_listen',
    value: function _listen(name, listening) {
      if (EVENT_TYPES$8.includes(name)) {
        this._nativeListen(name, listening);
      } else {
        _get(WebView.prototype.__proto__ || Object.getPrototypeOf(WebView.prototype), '_listen', this).call(this, name, listening);
      }
    }
  }, {
    key: 'postMessage',
    value: function postMessage(data, targetOrigin) {
      this._nativeCall('postMessage', {
        data: data,
        origin: targetOrigin
      });
      return this;
    }
  }, {
    key: 'goBack',
    value: function goBack() {
      this._nativeCall('goBack');
    }
  }, {
    key: 'goForward',
    value: function goForward() {
      this._nativeCall('goForward');
    }
  }, {
    key: '_loadData',
    value: function _loadData(data, mimeType) {
      this._nativeCall('loadData', { data: data, mimeType: mimeType });
    }
  }, {
    key: '_nativeType',
    get: function () {
      return 'tabris.WebView';
    }
  }]);

  return WebView;
}(Widget);

NativeObject.defineProperties(WebView.prototype, {
  url: { type: 'string', nocache: true },
  html: { type: 'string', nocache: true },
  headers: { type: 'any', default: {} },
  canGoBack: { type: 'boolean', readonly: true },
  canGoForward: { type: 'boolean', readonly: true },
  initScript: { type: 'string' }
});

var CONNECTING = 0;
var OPEN = 1;
var CLOSING = 2;
var CLOSED = 3;
var CONSTANTS = {
  CONNECTING: { value: CONNECTING },
  OPEN: { value: OPEN },
  CLOSING: { value: CLOSING },
  CLOSED: { value: CLOSED }
};
var EVENT_TYPES$9 = ['open', 'message', 'close', 'error'];

var _WebSocket = function (_NativeObject18) {
  _inherits(_WebSocket, _NativeObject18);

  function _WebSocket(properties) {
    _classCallCheck(this, _WebSocket);

    var _this69 = _possibleConstructorReturn(this, (_WebSocket.__proto__ || Object.getPrototypeOf(_WebSocket)).call(this));

    _this69._create('tabris.WebSocket', properties);
    EVENT_TYPES$9.forEach(function (type) {
      return _this69._nativeListen(type, true);
    });
    return _this69;
  }

  return _WebSocket;
}(NativeObject);

NativeObject.defineProperties(_WebSocket.prototype, {
  url: { type: 'string', default: '' },
  protocol: { type: 'any', default: '' },
  binaryType: { type: 'string', default: 'blob' },
  bufferedAmount: { type: 'number', nocache: true }
});

var WebSocket = function () {
  function WebSocket(url, protocol) {
    _classCallCheck(this, WebSocket);

    if (typeof url !== 'string') {
      throw new Error('The WebSocket url has to be of type string');
    }
    var scheme = extractScheme(url);
    if (!(scheme === 'ws' || scheme === 'wss')) {
      throw new Error("The WebSocket url has to have a scheme of 'ws' or 'wss' but is '" + scheme + "'");
    }
    if (typeof protocol !== 'string' && !Array.isArray(protocol)) {
      throw new Error('The WebSocket protocol has too be a string or an array of strings');
    }
    var protocols = Array.isArray(protocol) ? protocol : [protocol];
    this.url = url;
    this.readyState = CONNECTING;
    this.protocol = '';
    this.extensions = '';
    addDOMEventTargetMethods(this);
    defineEventHandlerProperties(this, EVENT_TYPES$9);
    this._proxy = this.$createProxy(url, protocols);
  }

  _createClass(WebSocket, [{
    key: '$createProxy',
    value: function $createProxy(url, protocols) {
      var _this70 = this;

      return new _WebSocket({
        url: url,
        protocol: protocols
      }).on('open', function (event) {
        _this70.readyState = OPEN;
        _this70.protocol = event.protocol;
        _this70.extensions = event.extensions;
        _this70.dispatchEvent(Object.assign(new Event('open'), omit(event, ['target', 'type', 'timeStamp'])));
      }).on('message', function (event) {
        if (_this70.readyState === OPEN) {
          _this70.dispatchEvent(Object.assign(new Event('message'), omit(event, ['target', 'type', 'timeStamp'])));
        }
      }).on('close', function (event) {
        _this70.readyState = CLOSED;
        _this70.dispatchEvent(Object.assign(new Event('close'), omit(event, ['target', 'type', 'timeStamp'])));
      }).on('error', function (event) {
        _this70.readyState = CLOSED;
        _this70.dispatchEvent(Object.assign(new Event('error'), omit(event, ['target', 'type', 'timeStamp'])));
      });
    }
  }, {
    key: 'send',
    value: function send(data) {
      if (this.readyState === CONNECTING) {
        throw new Error("Can not 'send' WebSocket message when WebSocket state is CONNECTING");
      }
      if (typeof data === 'string') {
        this._proxy._nativeCall('send', { data: data });
      } else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
        this._proxy._nativeCall('send', { data: data });
      } else {
        throw new Error('Data of type ' + typeof data + " is not supported in WebSocket 'send' operation");
      }
    }
  }, {
    key: 'close',
    value: function close(code, reason) {
      if (code && (typeof code !== 'number' || !(typeof code === 'number' && (code === 1000 || code >= 3000 && code <= 4999)))) {
        throw new Error('A given close code has to be either 1000 or in the range 3000 - 4999 inclusive');
      }
      if (reason && getStringByteSize(reason) > 123) {
        throw new Error('The close reason can not be larger than 123 utf-8 bytes');
      }
      if (this.readyState !== CLOSING && this.readyState !== CLOSED) {
        this.readyState = CLOSING;
        var _properties = {};
        if (code) {
          _properties.code = code;
        }
        if (reason) {
          _properties.reason = reason;
        }
        this._proxy._nativeCall('close', _properties);
      }
    }
  }, {
    key: 'binaryType',
    set: function (binaryType) {
      this._proxy.binaryType = binaryType;
    },
    get: function () {
      return this._proxy.binaryType;
    }
  }, {
    key: 'bufferedAmount',
    set: function (bufferedAmount) {
      warn('Can not set read-only property "bufferedAmount"');
    },
    get: function () {
      return this._proxy.bufferedAmount;
    }
  }]);

  return WebSocket;
}();

Object.defineProperties(WebSocket, CONSTANTS);
Object.defineProperties(WebSocket.prototype, CONSTANTS);

function getStringByteSize(input) {
  var len = 0;
  // TODO: workaround for https://github.com/babel/babili/issues/430
  if (!input.length) {
    return 0;
  }
  for (var i = 0; i < input.length; i++) {
    var code = input.charCodeAt(i);
    if (code <= 0x7f) {
      len += 1;
    } else if (code <= 0x7ff) {
      len += 2;
    } else if (code >= 0xd800 && code <= 0xdfff) {
      // Surrogate pair: These take 4 bytes in UTF-8 and 2 chars in UCS-2
      // (Assume next char is the other [valid] half and just skip it)
      len += 4;
      i++;
    } else if (code < 0xffff) {
      len += 3;
    } else {
      len += 4;
    }
  }
  return len;
}

function extractScheme(url) {
  var match = /^(\S+?):/.exec(url);
  return match ? match[1] : null;
}

var HttpRequest = function (_NativeObject19) {
  _inherits(HttpRequest, _NativeObject19);

  function HttpRequest() {
    _classCallCheck(this, HttpRequest);

    var _this71 = _possibleConstructorReturn(this, (HttpRequest.__proto__ || Object.getPrototypeOf(HttpRequest)).call(this));

    _this71._create('tabris.HttpRequest');
    _this71._nativeListen('stateChanged', true);
    _this71._nativeListen('downloadProgress', true);
    _this71._nativeListen('uploadProgress', true);
    return _this71;
  }

  _createClass(HttpRequest, [{
    key: 'abort',
    value: function abort() {
      this._nativeCall('abort', {});
    }
  }, {
    key: 'send',
    value: function send(config) {
      this._nativeCall('send', config);
    }
  }]);

  return HttpRequest;
}(NativeObject);

// XHR Spec: https://xhr.spec.whatwg.org/

var UNSENT = 0;
var OPENED = 1;
var HEADERS_RECEIVED = 2;
var LOADING = 3;
var DONE = 4;

var EVENT_TYPES$10 = ['loadstart', 'readystatechange', 'load', 'loadend', 'progress', 'timeout', 'abort', 'error'];
var UPLOAD_EVENT_TYPES = ['progress', 'loadstart', 'load', 'loadend', 'timeout', 'abort', 'error'];

var SUPPORTED_SCHEMES = ['http', 'https', 'file'];

var XMLHttpRequest = function () {
  function XMLHttpRequest() {
    _classCallCheck(this, XMLHttpRequest);

    this.$authorRequestHeaders = {};
    this.$timeout = 0;
    this.$status = 0;
    this.$statusText = '';
    this.$responseHeaders = '';
    this.$readyState = UNSENT;
    this.$responseData = '';
    this.$withCredentials = false;
    this.$responseType = '';
    this.$sendInvoked = false;
    this.$isSynchronous = false;
    this.$error = false;
    this.$uploadComplete = false;
    Object.defineProperty(this, 'upload', { value: {} });
    defineEventHandlerProperties(this, EVENT_TYPES$10);
    defineEventHandlerProperties(this.upload, UPLOAD_EVENT_TYPES);
    addDOMEventTargetMethods(this);
    addDOMEventTargetMethods(this.upload);
  }

  _createClass(XMLHttpRequest, [{
    key: 'open',
    value: function open(method, url, async) {
      var parsedUrl = {};
      // (2), (3), (4): we don't implement the 'settings' object
      validateRequiredOpenArgs(method, url);
      parsedUrl.source = url; // (8), (9): experimental non-standard parsing implementation:
      // regex taken from http://stackoverflow.com/a/19709846:
      parsedUrl.isRelative = !new RegExp('^(?:[a-z]+:)?//', 'i').test(url);
      if (typeof async === 'undefined') {
        // (10)
        async = true;
      }
      if (!async) {
        throw new Error('Only asynchronous request supported.');
      }
      // (12): superfluous as we don't support synchronous requests
      // TODO: (13) - should we call 'abort' to the proxy? We'd need to move the creation of the proxy
      // to the open() function
      this.$requestMethod = method; // (14)
      this.$requestUrl = parsedUrl;
      this.$isSynchronous = !async;
      this.$authorRequestHeaders = {};
      this.$sendInvoked = false;
      this.$responseData = null;
      if (this.$readyState !== OPENED) {
        // (15)
        this.$readyState = OPENED;
        dispatchEvent('readystatechange', this);
      }
    }
  }, {
    key: 'send',
    value: function send(data) {
      var _this72 = this;

      this.$proxy = new HttpRequest().on('stateChanged', function (event) {
        return handleStateChange(event, _this72);
      }).on('downloadProgress', function (event) {
        return dispatchProgressEvent('progress', _this72, event);
      }).on('uploadProgress', function (event) {
        return dispatchProgressEvent('progress', _this72.upload, event);
      });
      if (this.$readyState !== OPENED) {
        // (1)
        throw new Error("InvalidStateError: Object's state must be 'OPENED', failed to execute 'send'");
      }
      if (this.$sendInvoked) {
        // (2)
        throw new Error("InvalidStateError: 'send' invoked, failed to execute 'send'");
      }
      if (['GET', 'HEAD'].indexOf(this.$requestMethod) > -1) {
        // (3)
        data = null;
      }
      this.$requestBody = data; // (4)
      // TODO: support encoding and mimetype for string response types
      // (5): no storage mutex
      this.$error = this.$uploadComplete = false; // (6), see (8)
      if (!data) {
        // (7)
        this.$uploadComplete = true;
      }
      // (8): uploadEvents is relevant for the "force preflight flag", but this logic is handled by
      // the client
      // Basic access authentication
      this.$sendInvoked = true; // (9.1)
      dispatchProgressEvent('loadstart', this); // (9.2)
      if (!this.$uploadComplete) {
        dispatchProgressEvent('loadstart', this.upload); // (9.3)
      }
      // (10): only handling the same origin case
      this.$proxy.send({ // request URL fetch
        url: this.$requestUrl.source,
        method: this.$requestMethod,
        timeout: this.timeout,
        headers: this.$authorRequestHeaders,
        data: this.$requestBody,
        responseType: this.$responseType
      });
    }
  }, {
    key: 'abort',
    value: function abort() {
      if (this.$proxy) {
        this.$proxy.abort(); // (1)
      }
      if (!([UNSENT, OPENED].indexOf(this.$readyState) > -1 && !this.$sendInvoked || this.$readyState === DONE)) {
        // send() interrupted
        // (2.1), (2.2): setting readyState DONE with sendInvoked true or false seems to be an
        // internal state which doesn't affect the behavior and thus cannot be tested
        dispatchEvent('readystatechange', this); // (2.3)
        if (!this.$uploadComplete) {
          this.$uploadComplete = true; // (2.4.1)
          dispatchAbortProgressEvents(this.upload); // (2.4.2), (2.4.3), (2.4.4)
        }
        dispatchAbortProgressEvents(this); // (2.5), (2.6), (2.7)
      }
      this.$readyState = UNSENT; // (3)
    }
  }, {
    key: 'setRequestHeader',
    value: function setRequestHeader(header, value) {
      // #dom-xmlhttprequest-setrequestheader
      if (this.$readyState !== OPENED) {
        // (1)
        throw new Error('InvalidStateError: ' + "Object's state must be 'OPENED', failed to execute 'setRequestHeader'");
      }
      if (this.$sendInvoked) {
        // (2)
        throw new Error('InvalidStateError: ' + "cannot set request header if 'send()' invoked and request not completed");
      }
      if (!validHttpToken(header)) {
        // (3)
        throw new TypeError("Invalid HTTP header name, failed to execute 'open'");
      }
      if (!isValidHttpHeaderValue(value)) {
        // (4)
        throw new TypeError("Invalid HTTP header value, failed to execute 'open'");
      }
      // (5) (No headers are filtered out as this restriction does not apply to native apps)
      if (header in this.$authorRequestHeaders) {
        // (6):
        this.$authorRequestHeaders[header] = this.$authorRequestHeaders[header] + ', ' + value; // (7)
      } else {
        this.$authorRequestHeaders[header] = value; // (8)
      }
    }
  }, {
    key: 'getResponseHeader',
    value: function getResponseHeader(header) {
      // #the-getresponseheader()-method
      if ([UNSENT, OPENED].indexOf(this.readyState) > -1) {
        // (1)
        return null;
      }
      if (this.$error) {
        // (2)
        return null;
      }
      // (3) (No headers are filtered out as this restriction does not apply to native apps)
      for (var key in this.$responseHeaders) {
        // (4), (5)
        if (key.toLowerCase() === header.toLowerCase()) {
          return this.$responseHeaders[key];
        }
      }
      return null; // (6)
    }
  }, {
    key: 'getAllResponseHeaders',
    value: function getAllResponseHeaders() {
      // #the-getallresponseheaders()-method
      if ([UNSENT, OPENED].indexOf(this.readyState) > -1) {
        // (1)
        return '';
      }
      if (this.$error) {
        // (2)
        return '';
      }
      var result = [];
      for (var key in this.$responseHeaders) {
        result.push(key + ': ' + this.$responseHeaders[key]);
      }
      return result.join('\r\n');
    }
  }, {
    key: 'readyState',
    get: function () {
      return this.$readyState;
    }
  }, {
    key: 'timeout',
    get: function () {
      return this.$timeout;
    },
    set: function (value) {
      // (1): superfluous, as we don't support synchronous requests
      if (!isNaN(value)) {
        // (2)
        this.$timeout = Math.round(value);
      }
    }
  }, {
    key: 'responseText',
    get: function () {
      // 1. If responseType is not the empty string or "text", throw an InvalidStateError exception.
      if (this.$responseType !== '' && this.$responseType !== 'text') {
        throw new Error('XHR responseText not accessible for non-text responseType');
      }
      // 2. If state is not loading or done, return the empty string.
      if (this.$readyState !== LOADING && this.$readyState !== DONE) {
        return '';
      }
      // 3. Return the text response.
      return this.$responseData || '';
    }
  }, {
    key: 'response',
    get: function () {
      // If responseType is the empty string or "text"
      if (this.$responseType === '' || this.$responseType === 'string') {
        // 1. If state is not loading or done, return the empty string.
        if (this.$readyState !== LOADING && this.$readyState !== DONE) {
          return '';
        }
        // 2. Return the text response.
        return this.$responseData || '';
      }
      // Otherwise
      // 1. If state is not done, return null.
      if (this.$readyState !== DONE) {
        return null;
      }
      // 2. If responseType is "arraybuffer"
      // Return the arraybuffer response.
      return this.$responseData;
    }
  }, {
    key: 'responseType',
    get: function () {
      return this.$responseType;
    },
    set: function (value) {
      // 1. (concurrency related, skip)
      // 2. If state is loading or done, throw an InvalidStateError exception.
      if (this.$readyState === LOADING || this.$readyState === DONE) {
        throw new Error('The response type cannot be set when state is LOADING or DONE.');
      }
      // 3. (concurrency related, skip)
      // 4. Set the responseType attribute's value to the given value.
      // mimicking Chromium and Firefox behaviour when setting a not allowed responseType:
      if (['arraybuffer', 'blob', 'document', 'json', 'text'].indexOf(value) < 0) {
        return;
      }
      // currently only the response types 'text' and 'arraybuffer' are supported
      if (['blob', 'document', 'json'].indexOf(value) > -1) {
        throw new Error("Unsupported responseType, only 'text' and 'arraybuffer' are supported");
      }
      this.$responseType = value;
    }
  }, {
    key: 'status',
    get: function () {
      if ([OPENED, UNSENT].indexOf(this.$readyState) > -1) {
        return 0;
      }
      if (this.$error) {
        return 0;
      }
      return this.$status;
    }
  }, {
    key: 'statusText',
    get: function () {
      if ([OPENED, UNSENT].indexOf(this.$readyState) > -1) {
        return '';
      }
      if (this.$error) {
        return '';
      }
      return this.$statusText;
    }
  }, {
    key: 'withCredentials',
    get: function () {
      return this.$withCredentials;
    },
    set: function (value) {
      if (this.$readyState !== UNSENT && this.$readyState !== OPENED) {
        throw new Error("InvalidStateError: state must be 'UNSENT' or 'OPENED' when setting withCredentials");
      }
      if (this.$sendInvoked) {
        throw new Error("InvalidStateError: 'send' invoked, failed to set 'withCredentials'");
      }
      // (3): superfluous as we don't support synchronous requests
      // mimicking Chromium and Firefox behaviour when setting a non-boolean value:
      if (typeof value === 'boolean') {
        this.$withCredentials = value; // (4)
      }
    }
  }]);

  return XMLHttpRequest;
}();

Object.defineProperties(XMLHttpRequest.prototype, {
  UNSENT: { value: UNSENT },
  OPENED: { value: OPENED },
  HEADERS_RECEIVED: { value: HEADERS_RECEIVED },
  LOADING: { value: LOADING },
  DONE: { value: DONE }
});

function handleStateChange(event, xhr) {
  // Note: we supply lengthComputable, loaded and total only with the "progress" event types
  switch (event.state) {
    case 'headers':
      xhr.$readyState = HEADERS_RECEIVED;
      xhr.$status = event.code;
      xhr.$statusText = event.message;
      xhr.$responseHeaders = event.headers;
      dispatchEvent('readystatechange', xhr);
      xhr.$uploadComplete = true; // #make-upload-progress-notifications
      dispatchFinishedProgressEvents(xhr.upload);
      break;
    case 'loading':
      xhr.$readyState = LOADING;
      dispatchEvent('readystatechange', xhr);
      break;
    case 'finished':
      // TODO create response based on responseType
      xhr.$responseData = event.response;
      xhr.$readyState = DONE;
      dispatchEvent('readystatechange', xhr);
      dispatchFinishedProgressEvents(xhr);
      dispatchFinishedProgressEvents(xhr.upload);
      xhr.$proxy.dispose();
      xhr.$proxy = null;
      break;
    case 'error':
      handleRequestError('error', xhr);
      break;
    case 'timeout':
      handleRequestError('timeout', xhr);
      break;
    case 'abort':
      handleRequestError('abort', xhr);
      break;
  }
}

function handleRequestError(type, xhr) {
  xhr.$error = true; // (1*) (#terminate-the-request)
  xhr.$readyState = DONE; // (1)
  // (2): superfluous as we don't support synchronous requests
  dispatchEvent('readystatechange', xhr); // (3)
  dispatchErrorProgressEvents(type, xhr);
  if (!xhr.$uploadComplete) {
    xhr.$uploadComplete = true;
    dispatchErrorProgressEvents(type, xhr.upload);
  }
  xhr.$proxy.dispose();
  xhr.$proxy = null;
}

function validateRequiredOpenArgs(method, url) {
  if (!method) {
    throw new TypeError("Method argument should be specified to execute 'open'");
  }
  if (!url) {
    throw new TypeError("URL argument should be specified to execute 'open'");
  }
  validateMethod(method);
  validateUrl(url);
}

function validateMethod(method) {
  if (!validHttpToken(method)) {
    throw new TypeError("Invalid HTTP method, failed to execute 'open'");
  }
  // (6):
  var tokens = ['CONNECT', 'DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT', 'TRACE', 'TRACK'];
  var uppercaseMethod = method.toUpperCase();
  if (tokens.indexOf(uppercaseMethod) >= 0) {
    method = uppercaseMethod;
  }
  var forbiddenTokens = ['CONNECT', 'TRACE', 'TRACK']; // (7)
  if (forbiddenTokens.indexOf(method) >= 0) {
    throw new Error('SecurityError: \'' + method + '\' HTTP method is not secure, failed to execute \'open\'');
  }
}

function validHttpToken(httpToken) {
  // RFC-compliant validation for HTTP tokens ported from Chromium:
  // https://chromium.googlesource.com/chromium/blink.git/+/master/Source/platform/network/HTTPParsers.cpp
  var forbiddenCharacters = ['(', ')', '<', '>', '@', ',', ';', ':', '\\', '"', '/', '[', ']', '?', '=', '{', '}'];
  return !(/[^\x21-\x7E]/.test(httpToken) || forbiddenCharacters.indexOf(httpToken) >= 0);
}

function isValidHttpHeaderValue(value) {
  // non-RFC compliant validation for HTTP header values ported from Chromium:
  // https://chromium.googlesource.com/chromium/blink.git/+/master/Source/platform/network/HTTPParsers.cpp
  // Regex for Latin-1 characters based on: http://www.ic.unicamp.br/~stolfi/EXPORT/www/ISO-8859-1-Encoding.html
  return (/^[\x09\x0A\x0D\x20-\x7E\xA0-\xFF]*$/.test(value) && value.indexOf('\n') < 0 && value.indexOf('\r') < 0
  );
}

function validateUrl(url) {
  // TODO: rewrite (8),(9)
  var scheme = extractScheme$1(url);
  if (scheme && SUPPORTED_SCHEMES.indexOf(scheme) === -1) {
    throw new SyntaxError("Unsupported URL scheme, failed to execute 'open'");
  }
}

function extractScheme$1(url) {
  var match = /^(\S+?):/.exec(url);
  return match ? match[1] : null;
}

function dispatchEvent(type, target) {
  target.dispatchEvent(new Event(type));
}

function dispatchProgressEvent(type, target, config) {
  target.dispatchEvent(new ProgressEvent(type, config));
}

function dispatchAbortProgressEvents(target) {
  dispatchProgressEvent('progress', target);
  dispatchProgressEvent('abort', target);
  dispatchProgressEvent('loadend', target);
}

function dispatchErrorProgressEvents(type, target) {
  dispatchProgressEvent('progress', target);
  dispatchProgressEvent(type, target);
  dispatchProgressEvent('loadend', target);
}

function dispatchFinishedProgressEvents(target) {
  // Note: progress event is dispatched separately by the downloadProgress/uploadProgress callbacks
  dispatchProgressEvent('load', target);
  dispatchProgressEvent('loadend', target);
}

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */

var Headers = function () {
  function Headers(headers) {
    var _this73 = this;

    _classCallCheck(this, Headers);

    this.$map = {};
    if (headers instanceof Headers) {
      headers.forEach(function (value, name) {
        return _this73.append(name, value);
      });
    } else if (Array.isArray(headers)) {
      headers.forEach(function (header) {
        return _this73.append(header[0], header[1]);
      });
    } else if (headers) {
      Object.getOwnPropertyNames(headers).forEach(function (name) {
        return _this73.append(name, headers[name]);
      });
    }
  }

  _createClass(Headers, [{
    key: 'append',
    value: function append(name, value) {
      name = normalizeName(name);
      var oldValue = this.$map[name];
      this.$map[name] = oldValue ? oldValue + ',' + value : '' + value;
    }
  }, {
    key: 'delete',
    value: function _delete(name) {
      delete this.$map[normalizeName(name)];
    }
  }, {
    key: 'get',
    value: function get(name) {
      name = normalizeName(name);
      return this.has(name) ? this.$map[name] : null;
    }
  }, {
    key: 'has',
    value: function has(name) {
      return this.$map.hasOwnProperty(normalizeName(name));
    }
  }, {
    key: 'set',
    value: function set(name, value) {
      this.$map[normalizeName(name)] = '' + value;
    }
  }, {
    key: 'forEach',
    value: function forEach(callback, thisArg) {
      for (var name in this.$map) {
        if (this.$map.hasOwnProperty(name)) {
          callback.call(thisArg, this.$map[name], name, this);
        }
      }
    }
  }, {
    key: 'keys',
    value: function keys() {
      var items = [];
      this.forEach(function (value, name) {
        return items.push(name);
      });
      return iteratorFor(items);
    }
  }, {
    key: 'values',
    value: function values() {
      var items = [];
      this.forEach(function (value) {
        return items.push(value);
      });
      return iteratorFor(items);
    }
  }, {
    key: 'entries',
    value: function entries() {
      var items = [];
      this.forEach(function (value, name) {
        return items.push([name, value]);
      });
      return iteratorFor(items);
    }
  }, {
    key: iteratorSymbol(),
    value: function () {
      return this.entries();
    }
  }]);

  return Headers;
}();

function normalizeName(name) {
  name = '' + name;
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name');
  }
  return name.toLowerCase();
}

function iteratorFor(items) {
  var iterator = {
    next: function () {
      var value = items.shift();
      return { done: value === undefined, value: value };
    }
  };
  iterator[iteratorSymbol()] = function () {
    return iterator;
  };
  return iterator;
}

// TODO replace when ES6 iterator is available on all platforms
function iteratorSymbol() {
  return 'Symbol' in global && 'iterator' in global.Symbol ? global.Symbol.iterator : '@@iterator';
}

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */

var Body = function () {
  function Body() {
    _classCallCheck(this, Body);
  }

  _createClass(Body, [{
    key: '_initBody',
    value: function _initBody(body) {
      this._bodyInit = body;
      if (!body) {
        this._bodyText = '';
      } else if (typeof body === 'string') {
        this._bodyText = body;
      } else if (ArrayBuffer.prototype.isPrototypeOf(body) || ArrayBuffer.isView(body)) {
        this._bodyBuffer = body.slice(0);
      } else {
        throw new Error('unsupported BodyInit type');
      }
    }
  }, {
    key: 'text',
    value: function text() {
      return this.$consumed() || Promise.resolve(this._bodyBuffer ? TextDecoder.decode(this._bodyBuffer, this._encoding) : this._bodyText);
    }
  }, {
    key: 'json',
    value: function json() {
      return this.text().then(JSON.parse);
    }
  }, {
    key: 'arrayBuffer',
    value: function arrayBuffer() {
      return this.$consumed() || Promise.resolve(this._bodyBuffer);
    }
  }, {
    key: '$consumed',
    value: function $consumed() {
      if (this.$bodyUsed) {
        return Promise.reject(new TypeError('Already read'));
      }
      this.$bodyUsed = true;
    }
  }, {
    key: 'bodyUsed',
    get: function () {
      return !!this.$bodyUsed;
    }
  }, {
    key: '_encoding',
    get: function () {}
  }]);

  return Body;
}();

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */
// HTTP methods whose capitalization should be normalized


var METHODS = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

var Request = function (_Body) {
  _inherits(Request, _Body);

  function Request(input) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Request);

    var _this74 = _possibleConstructorReturn(this, (Request.__proto__ || Object.getPrototypeOf(Request)).call(this));

    var body = options.body;
    if (input instanceof Request) {
      if (input.bodyUsed) {
        throw new TypeError('Already read');
      }
      if (!body && input._bodyInit != null) {
        body = input._bodyInit;
        input.$bodyUsed = true;
      }
    } else {
      input = {
        url: input
      };
    }
    Object.defineProperties(_this74, {
      url: { value: '' + input.url },
      method: { value: normalizeMethod(options.method || input.method || 'GET') },
      headers: { value: new Headers(options.headers || input.headers || {}) },
      credentials: { value: options.credentials || input.credentials || 'omit' },
      mode: { value: options.mode || input.mode || null },
      referrer: { value: '' },
      timeout: { value: options.timeout || 0 }
    });
    if ((_this74.method === 'GET' || _this74.method === 'HEAD') && body) {
      throw new TypeError('Body not allowed for GET or HEAD requests');
    }
    _this74._initBody(body);
    return _this74;
  }

  _createClass(Request, [{
    key: 'clone',
    value: function clone() {
      return new Request(this, {
        body: this._bodyInit
      });
    }
  }]);

  return Request;
}(Body);

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return METHODS.includes(upcased) ? upcased : method;
}

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */
var REDIRECT_STATUSES = [301, 302, 303, 307, 308];

var Response = function (_Body2) {
  _inherits(Response, _Body2);

  function Response(bodyInit) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Response);

    var _this75 = _possibleConstructorReturn(this, (Response.__proto__ || Object.getPrototypeOf(Response)).call(this));

    Object.defineProperties(_this75, {
      url: { value: options.url || '' },
      type: { value: options._type || 'default' },
      status: { value: 'status' in options ? options.status : 200 },
      statusText: { value: 'statusText' in options ? options.statusText : 'OK' },
      headers: { value: new Headers(options.headers) }
    });
    _this75._initBody(bodyInit);
    return _this75;
  }

  _createClass(Response, [{
    key: 'clone',
    value: function clone() {
      return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
      });
    }
  }, {
    key: 'ok',
    get: function () {
      return this.status >= 200 && this.status < 300;
    }
  }, {
    key: '_encoding',
    get: function () {
      var contentType = this.headers.get('content-type') || '';
      var parameters = contentType.split(';').slice(1);
      for (var param of parameters) {
        var match = /charset=(\S+)/i.exec(param.trim());
        if (match) {
          return match[1].toLowerCase();
        }
      }
      return null;
    }
  }], [{
    key: 'error',
    value: function error() {
      return new Response(null, { status: 0, statusText: '', _type: 'error' });
    }
  }, {
    key: 'redirect',
    value: function redirect(url, status) {
      if (!REDIRECT_STATUSES.includes(status)) {
        throw new RangeError('Invalid status code');
      }
      return new Response(null, { status: status, headers: { location: url } });
    }
  }]);

  return Response;
}(Body);

/**
 * Original work Copyright (c) 2014-2016 GitHub, Inc.
 * Implementation based on https://github.com/github/fetch
 */


function fetch(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);
    var hr = new HttpRequest();
    var options = {};
    hr.on('stateChanged', function (event) {
      switch (event.state) {
        case 'headers':
          options.status = event.code;
          options.statusText = event.message;
          options.headers = new Headers(event.headers);
          break;
        case 'finished':
          options.url = options.headers.get('X-Request-URL') || request.url;
          resolve(new Response(event.response, options));
          hr.dispose();
          break;
        case 'error':
          reject(new TypeError('Network request failed'));
          hr.dispose();
          break;
        case 'timeout':
          reject(new TypeError('Network request timed out'));
          hr.dispose();
          break;
        case 'abort':
          reject(new TypeError('Network request aborted'));
          hr.dispose();
          break;
      }
    });
    hr.send({
      url: request.url,
      method: request.method,
      responseType: 'arraybuffer',
      data: typeof request._bodyInit === 'undefined' ? null : request._bodyInit,
      headers: encodeHeaders(request.headers),
      timeout: request.timeout
    });
  });
}

function encodeHeaders(headers) {
  var map = {};
  headers.forEach(function (value, name) {
    return map[name] = value;
  });
  return map;
}

var window$1 = global.window;

if (global.tabris && global.tabris.version) {
  throw new Error('tabris module already loaded. Ensure the module is installed only once.');
}

module.exports = global.tabris = Object.assign(new Tabris(), {
  Action: Action,
  ActionSheet: ActionSheet,
  ActivityIndicator: ActivityIndicator,
  AlertDialog: AlertDialog,
  App: App,
  Button: Button,
  Canvas: Canvas,
  CheckBox: CheckBox,
  CollectionView: CollectionView,
  Composite: Composite,
  ContentView: ContentView,
  Crypto: Crypto,
  DateDialog: DateDialog,
  Device: Device,
  Drawer: Drawer,
  Event: Event,
  EventObject: EventObject,
  FileSystem: FileSystem,
  ImageData: ImageData,
  ImageView: ImageView,
  InactivityTimer: InactivityTimer,
  NativeObject: NativeObject,
  NavigationView: NavigationView,
  NavigationBar: NavigationBar,
  Page: Page,
  Picker: Picker,
  Printer: Printer,
  ProgressBar: ProgressBar,
  ProgressEvent: ProgressEvent,
  RadioButton: RadioButton,
  RefreshComposite: RefreshComposite,
  ScrollView: ScrollView,
  SearchAction: SearchAction,
  Slider: Slider,
  Storage: Storage,
  StatusBar: StatusBar,
  Switch: Switch,
  Tab: Tab,
  TabFolder: TabFolder,
  TextInput: TextInput,
  TextView: TextView,
  TimeDialog: TimeDialog,
  ToggleButton: ToggleButton,
  Ui: Ui,
  Video: Video,
  WebSocket: WebSocket,
  WebView: WebView,
  Widget: Widget,
  WidgetCollection: WidgetCollection,
  XMLHttpRequest: XMLHttpRequest,
  fetch: fetch,
  Headers: Headers,
  Request: Request,
  Response: Response
});

Object.assign(window$1, {
  Crypto: Crypto,
  ImageData: ImageData,
  ProgressEvent: ProgressEvent,
  Storage: Storage,
  WebSocket: WebSocket,
  XMLHttpRequest: XMLHttpRequest,
  fetch: fetch,
  Headers: Headers,
  Request: Request,
  Response: Response,
  JSX: JSX
});

tabris.on('start', function () {
  tabris.app = create$2();
  checkVersion(tabris.version, tabris.app._nativeGet('tabrisJsVersion'));
  tabris.ui = create$3();
  tabris.device = create();
  tabris.printer = create$1();
  tabris.fs = create$8();
  publishDeviceProperties(tabris.device, window$1);
  window$1.localStorage = tabris.localStorage = create$9();
  if (tabris.device.platform === 'iOS') {
    window$1.secureStorage = tabris.secureStorage = create$9(true);
  }
  window$1.crypto = tabris.crypto = new Crypto();
  if (window$1.console.print) {
    window$1.console = createConsole(window$1.console);
  }
  tabris.pkcs5 = new Pkcs5();
});

addDOMDocument(window$1);
addDOMEventTargetMethods(window$1);
addWindowTimerMethods(window$1);
