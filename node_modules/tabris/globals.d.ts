interface EventInit {
    bubbles?: boolean;
    cancelable?: boolean;
}

interface Event {
    readonly bubbles: boolean;
    readonly cancelable: boolean;
    readonly currentTarget: EventTarget;
    readonly defaultPrevented: boolean;
    readonly eventPhase: number;
    readonly isTrusted: boolean;
    readonly target: EventTarget;
    readonly timeStamp: number;
    readonly type: string;
    initEvent(eventTypeArg: string, canBubbleArg: boolean, cancelableArg: boolean): void;
    preventDefault(): void;
    stopImmediatePropagation(): void;
    stopPropagation(): void;
    readonly AT_TARGET: number;
    readonly BUBBLING_PHASE: number;
    readonly CAPTURING_PHASE: number;
}

type CustomEvent = Event; // Required for compatibility with @types/WinRT

declare var Event: {
    prototype: Event;
    new(typeArg: string, eventInitDict?: EventInit): Event;
    readonly AT_TARGET: number;
    readonly BUBBLING_PHASE: number;
    readonly CAPTURING_PHASE: number;
}

interface EventListener {
    (evt: Event): void;
}

interface EventTarget {
    addEventListener(type: string, listener?: EventListener, useCapture?: boolean): void;
    dispatchEvent(evt: Event): boolean;
    removeEventListener(type: string, listener?: EventListener, useCapture?: boolean): void;
}

declare var EventTarget: {
    prototype: EventTarget;
    new(): EventTarget;
}

interface ProgressEventInit extends EventInit {
    lengthComputable?: boolean;
    loaded?: number;
    total?: number;
}

interface ProgressEvent extends Event {
    readonly lengthComputable: boolean;
    readonly loaded: number;
    readonly total: number;
    initProgressEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, lengthComputableArg: boolean, loadedArg: number, totalArg: number): void;
}

declare var ProgressEvent: {
    prototype: ProgressEvent;
    new(type: string, eventInitDict?: ProgressEventInit): ProgressEvent;
}

interface ErrorEventInit extends EventInit {
    message?: string;
    filename?: string;
    lineno?: number;
    colno?: number;
    error?: any;
}

interface ErrorEvent extends Event {
    readonly colno: number;
    readonly error: any;
    readonly filename: string;
    readonly lineno: number;
    readonly message: string;
    initErrorEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, messageArg: string, filenameArg: string, linenoArg: number): void;
}

declare var ErrorEvent: {
    prototype: ErrorEvent;
    new(type: string, errorEventInitDict?: ErrorEventInit): ErrorEvent;
}

interface CloseEventInit extends EventInit {
    wasClean?: boolean;
    code?: number;
    reason?: string;
}

interface CloseEvent extends Event {
    readonly code: number;
    readonly reason: string;
    readonly wasClean: boolean;
    initCloseEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, wasCleanArg: boolean, codeArg: number, reasonArg: string): void;
}

declare var CloseEvent: {
    prototype: CloseEvent;
    new(typeArg: string, eventInitDict?: CloseEventInit): CloseEvent;
}


interface MessageEventInit extends EventInit {
    lastEventId?: string;
    channel?: string;
    data?: any;
    origin?: string;
    source?: any;
    ports?: MessagePort[];
}

interface MessageEvent extends Event {
    readonly data: any;
    readonly origin: string;
    readonly ports: any;
    readonly source: any;
    initMessageEvent(typeArg: string, canBubbleArg: boolean, cancelableArg: boolean, dataArg: any, originArg: string, lastEventIdArg: string, sourceArg: any): void;
}

declare var MessageEvent: {
    prototype: MessageEvent;
    new(type: string, eventInitDict?: MessageEventInit): MessageEvent;
}

declare var MessageEvent: {
    prototype: MessageEvent;
    new(type: string, eventInitDict?: MessageEventInit): MessageEvent;
}

interface MessagePortEventMap {
    "message": MessageEvent;
}

interface MessagePort extends EventTarget {
    onmessage: (this: MessagePort, ev: MessageEvent) => any;
    close(): void;
    postMessage(message?: any, transfer?: any[]): void;
    start(): void;
    addEventListener<K extends keyof MessagePortEventMap>(type: K, listener: (this: MessagePort, ev: MessagePortEventMap[K]) => any, useCapture?: boolean): void;
}

declare var MessagePort: {
    prototype: MessagePort;
    new(): MessagePort;
}

interface WebSocketEventMap {
    "close": CloseEvent;
    "error": Event;
    "message": MessageEvent;
    "open": Event;
}

interface WebSocket extends EventTarget {
    binaryType: string;
    readonly bufferedAmount: number;
    readonly extensions: string;
    onclose: (this: WebSocket, ev: CloseEvent) => any;
    onerror: (this: WebSocket, ev: Event) => any;
    onmessage: (this: WebSocket, ev: MessageEvent) => any;
    onopen: (this: WebSocket, ev: Event) => any;
    readonly protocol: string;
    readonly readyState: number;
    readonly url: string;
    close(code?: number, reason?: string): void;
    send(data: any): void;
    readonly CLOSED: number;
    readonly CLOSING: number;
    readonly CONNECTING: number;
    readonly OPEN: number;
    addEventListener<K extends keyof WebSocketEventMap>(type: K, listener: (this: WebSocket, ev: WebSocketEventMap[K]) => any, useCapture?: boolean): void;
}

declare var WebSocket: {
    prototype: WebSocket;
    new(url: string, protocols?: string | string[]): WebSocket;
    readonly CLOSED: number;
    readonly CLOSING: number;
    readonly CONNECTING: number;
    readonly OPEN: number;
}

// Type definitions for fetch API
// Source: https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/56295f5058cac7ae458540423c50ac2dcf9fc711/whatwg-fetch/whatwg-fetch.d.ts
// Project: https://github.com/github/fetch
// Definitions by: Ryan Graham <https://github.com/ryan-codingintrigue>

declare class Request extends Body {
  constructor(input: string | Request, init?: RequestInit);
  method: string;
  url: string;
  headers: Headers;
  context: RequestContext;
  referrer: string;
  mode: RequestMode;
  credentials: RequestCredentials;
  cache: RequestCache;
}

interface RequestInit {
  method?: string;
  headers?: HeaderInit | { [index: string]: string };
  body?: BodyInit;
  mode?: RequestMode;
  credentials?: RequestCredentials;
  cache?: RequestCache;
}

type RequestContext =
  "audio" | "beacon" | "cspreport" | "download" | "embed" |
  "eventsource" | "favicon" | "fetch" | "font" | "form" | "frame" |
  "hyperlink" | "iframe" | "image" | "imageset" | "import" |
  "internal" | "location" | "manifest" | "object" | "ping" | "plugin" |
  "prefetch" | "script" | "serviceworker" | "sharedworker" |
  "subresource" | "style" | "track" | "video" | "worker" |
  "xmlhttprequest" | "xslt";
type RequestMode = "same-origin" | "no-cors" | "cors";
type RequestCredentials = "omit" | "same-origin" | "include";
type RequestCache =
  "default" | "no-store" | "reload" | "no-cache" |
  "force-cache" | "only-if-cached";

declare class Headers {
  append(name: string, value: string): void;
  delete(name: string): void;
  get(name: string): string;
  getAll(name: string): Array<string>;
  has(name: string): boolean;
  set(name: string, value: string): void;
  forEach(callback: (value: string, name: string) => void): void;
}

declare class Body {
  bodyUsed: boolean;
  arrayBuffer(): Promise<ArrayBuffer>;
  // TODO: enable when Blob support is added
  // blob(): Promise<Blob>;
  // formData(): Promise<FormData>;
  json(): Promise<any>;
  json<T>(): Promise<T>;
  text(): Promise<string>;
}
declare class Response extends Body {
  constructor(body?: BodyInit, init?: ResponseInit);
  error(): Response;
  redirect(url: string, status: number): Response;
  type: ResponseType;
  url: string;
  status: number;
  ok: boolean;
  statusText: string;
  headers: Headers;
  clone(): Response;
}

type ResponseType = "basic" | "cors" | "default" | "error" | "opaque";

interface ResponseInit {
  status: number;
  statusText?: string;
  headers?: HeaderInit;
}

declare type HeaderInit = Headers | Array<string>;
// TODO: enable when Blob support is added
// declare type BodyInit = Blob | FormData | string;
declare type BodyInit = string;
declare type RequestInfo = Request | string;

declare function fetch(url: string | Request, init?: RequestInit): Promise<Response>;

interface XMLHttpRequestEventTarget {
    onabort: (this: XMLHttpRequestEventTarget, ev: Event) => any;
    onerror: (this: XMLHttpRequestEventTarget, ev: ErrorEvent) => any;
    onload: (this: XMLHttpRequestEventTarget, ev: Event) => any;
    onloadend: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;
    onloadstart: (this: XMLHttpRequestEventTarget, ev: Event) => any;
    onprogress: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;
    ontimeout: (this: XMLHttpRequestEventTarget, ev: ProgressEvent) => any;
    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestEventTarget, ev: XMLHttpRequestEventTargetEventMap[K]) => any, useCapture?: boolean): void;
    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
}

interface XMLHttpRequestEventTargetEventMap {
    "abort": Event;
    "error": ErrorEvent;
    "load": Event;
    "loadend": ProgressEvent;
    "loadstart": Event;
    "progress": ProgressEvent;
    "timeout": ProgressEvent;
}

interface XMLHttpRequestEventMap extends XMLHttpRequestEventTargetEventMap {
    "readystatechange": Event;
}


interface XMLHttpRequest extends EventTarget, XMLHttpRequestEventTarget {
    onreadystatechange: (this: XMLHttpRequest, ev: Event) => any;
    readonly readyState: number;
    readonly response: any;
    readonly responseText: string;
    responseType: 'text' | 'arraybuffer' | '';
    readonly status: number;
    readonly statusText: string;
    timeout: number;
    readonly upload: XMLHttpRequestUpload;
    withCredentials: boolean;
    abort(): void;
    getAllResponseHeaders(): string;
    getResponseHeader(header: string): string | null;
    open(method: string, url: string, async?: boolean, user?: string, password?: string): void;
    send(data?: string): void;
    send(data?: any): void;
    setRequestHeader(header: string, value: string): void;
    readonly DONE: number;
    readonly HEADERS_RECEIVED: number;
    readonly LOADING: number;
    readonly OPENED: number;
    readonly UNSENT: number;
    addEventListener<K extends keyof XMLHttpRequestEventMap>(type: K, listener: (this: XMLHttpRequest, ev: XMLHttpRequestEventMap[K]) => any, useCapture?: boolean): void;
    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
}

declare var XMLHttpRequest: {
    prototype: XMLHttpRequest;
    new(): XMLHttpRequest;
    readonly DONE: number;
    readonly HEADERS_RECEIVED: number;
    readonly LOADING: number;
    readonly OPENED: number;
    readonly UNSENT: number;
}

interface XMLHttpRequestUpload extends EventTarget, XMLHttpRequestEventTarget {
    addEventListener<K extends keyof XMLHttpRequestEventTargetEventMap>(type: K, listener: (this: XMLHttpRequestUpload, ev: XMLHttpRequestEventTargetEventMap[K]) => any, useCapture?: boolean): void;
    addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;
}

declare var XMLHttpRequestUpload: {
    prototype: XMLHttpRequestUpload;
    new(): XMLHttpRequestUpload;
}

// Console

/**
 * The console object provides access to the debugging console
 */
declare class Console {

  private constructor();

  /**
   * Outputs a debug message to the console.
   * @param objects A list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
   */
  debug(...objects: any[]): void;

  /**
   * Outputs a debug message to the console.
   * @param message A JavaScript string containing zero or more substitution strings.
   * @param substitutions JavaScript objects with which to replace substitution strings within message
   */
  debug(message?: string, ...substitutions: any[]): void;

  /**
   * Outputs an error message to the console.
   * @param objects A list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
   */
  error(...objects: any[]): void;

  /**
   * Outputs an error message to the console.
   * @param message A JavaScript string containing zero or more substitution strings.
   * @param substitutions JavaScript objects with which to replace substitution strings within message
   */
  error(message?: string, ...substitutions: any[]): void;

  /**
   * Outputs an info message to the console.
   * @param objects A list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
   */
  info(...objects: any[]): void;

  /**
   * Outputs an info message to the console.
   * @param message A JavaScript string containing zero or more substitution strings.
   * @param substitutions JavaScript objects with which to replace substitution strings within message
   */
  info(message?: string, ...substitutions: any[]): void;

  /**
   * Outputs a message to the console.
   * @param objects A list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
   */
  log(...objects: any[]): void;

  /**
   * Outputs a message to the console.
   * @param message A JavaScript string containing zero or more substitution strings.
   * @param substitutions JavaScript objects with which to replace substitution strings within message
   */
  log(message?: string, ...substitutions: any[]): void;

  /**
   * Outputs a warning message to the console.
   * @param objects A list of JavaScript objects to output. The string representations of each of these objects are appended together in the order listed and output.
   */
  warn(...objects: any[]): void;

  /**
   * Outputs a warning message to the console.
   * @param message A JavaScript string containing zero or more substitution strings.
   * @param substitutions JavaScript objects with which to replace substitution strings within message
   */
  warn(message?: string, ...substitutions: any[]): void;
}

declare var console: Console;

// Storage

/**
 * The `localStorage` object allows storing key-value pairs in a persistent store. Both keys and values
 * are stored as strings.
 * On iOS, there is an additional object `secureStorage` available in the global scope. This is a
 * drop-in replacement for `localStorage` that keeps data in the encrypted iOS Keychain.
 * The `localStorage` is only meant to store relatively short strings. To store larger amounts of data
 * it is recommended to use the [FileSystem](./fs.html) API.
 */
declare class Storage {

  private constructor();

  /**
   * Remove all key/value pairs from the storage.
   */
  clear(): void;

  /**
   * Retrieves the value associated with the given key.
   * @param key 
   */
  getItem(key: string): string|null;

  /**
   * Removes the given key/value pair from the storage.
   * @param key 
   */
  removeItem(key: string): void;

  /**
   * Stores a string value using the given key.
   * @param key 
   * @param value 
   */
  setItem(key: string, value: string): void;
}

declare var localStorage: Storage;

// Timer


/**
 * Cancels the running interval associated with the given ID. When given an invalid ID, nothing happens.
 * @param id The ID that was returned by `setInterval`.
 */
declare function clearInterval(id: any): void;

/**
 * Cancels the running timeout associated with the given ID. When given an invalid ID, nothing happens.
 * @param id The ID that was returned by `setTimeout`.
 */
declare function clearTimeout(id: any): void;

/**
 * Calls the given function repeatedly, each times waiting the given delay. The actual delay may be
 * slightly longer than the given one.
 * @param callback The function to call.
 * @param delay The delay in milliseconds.
 * @param params One or more values passed on to the callback.
 */
declare function setInterval(callback: Function, delay?: number, ...params: any[]): any;

/**
 * Calls the given function with `param` (and all following parameters) after the specified delay. The
 * actual delay may be slightly longer than the given one.
 * @param callback The function to call.
 * @param delay The delay in milliseconds.
 * @param params One or more values passed on to the callback.
 */
declare function setTimeout(callback: Function, delay?: number, ...params: any[]): any;

